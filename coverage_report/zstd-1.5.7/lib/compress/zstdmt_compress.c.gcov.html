<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - zstd-1.5.7/lib/compress/zstdmt_compress.c</title>
  <link rel="stylesheet" type="text/css" href="../../../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../../../index.html">top level</a> - <a href="index.html">zstd-1.5.7/lib/compress</a> - zstdmt_compress.c<span style="font-size: 80%;"> (source / <a href="zstdmt_compress.c.func-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryLo">0.0&nbsp;%</td>
            <td class="headerCovTableEntry">943</td>
            <td class="headerCovTableEntry">0</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2026-02-03 18:12:40</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntryLo">0.0&nbsp;%</td>
            <td class="headerCovTableEntry">56</td>
            <td class="headerCovTableEntry">0</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
            | Branches:
            <span class="coverLegendCov">+</span> taken
            <span class="coverLegendNoCov">-</span> not taken
            <span class="coverLegendNoCov">#</span> not executed
</td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntryHi">-</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
          </tr>
                  <tr><td><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">             Branch data     Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>                 :             : /*</span>
<span id="L2"><span class="lineNum">       2</span>                 :             :  * Copyright (c) Meta Platforms, Inc. and affiliates.</span>
<span id="L3"><span class="lineNum">       3</span>                 :             :  * All rights reserved.</span>
<span id="L4"><span class="lineNum">       4</span>                 :             :  *</span>
<span id="L5"><span class="lineNum">       5</span>                 :             :  * This source code is licensed under both the BSD-style license (found in the</span>
<span id="L6"><span class="lineNum">       6</span>                 :             :  * LICENSE file in the root directory of this source tree) and the GPLv2 (found</span>
<span id="L7"><span class="lineNum">       7</span>                 :             :  * in the COPYING file in the root directory of this source tree).</span>
<span id="L8"><span class="lineNum">       8</span>                 :             :  * You may select, at your option, one of the above-listed licenses.</span>
<span id="L9"><span class="lineNum">       9</span>                 :             :  */</span>
<span id="L10"><span class="lineNum">      10</span>                 :             : </span>
<span id="L11"><span class="lineNum">      11</span>                 :             : </span>
<span id="L12"><span class="lineNum">      12</span>                 :             : /* ======   Compiler specifics   ====== */</span>
<span id="L13"><span class="lineNum">      13</span>                 :             : #if defined(_MSC_VER)</span>
<span id="L14"><span class="lineNum">      14</span>                 :             : #  pragma warning(disable : 4204)   /* disable: C4204: non-constant aggregate initializer */</span>
<span id="L15"><span class="lineNum">      15</span>                 :             : #endif</span>
<span id="L16"><span class="lineNum">      16</span>                 :             : </span>
<span id="L17"><span class="lineNum">      17</span>                 :             : </span>
<span id="L18"><span class="lineNum">      18</span>                 :             : /* ======   Dependencies   ====== */</span>
<span id="L19"><span class="lineNum">      19</span>                 :             : #include &quot;../common/allocations.h&quot; /* ZSTD_customMalloc, ZSTD_customCalloc, ZSTD_customFree */</span>
<span id="L20"><span class="lineNum">      20</span>                 :             : #include &quot;../common/zstd_deps.h&quot;   /* ZSTD_memcpy, ZSTD_memset, INT_MAX, UINT_MAX */</span>
<span id="L21"><span class="lineNum">      21</span>                 :             : #include &quot;../common/mem.h&quot;         /* MEM_STATIC */</span>
<span id="L22"><span class="lineNum">      22</span>                 :             : #include &quot;../common/pool.h&quot;        /* threadpool */</span>
<span id="L23"><span class="lineNum">      23</span>                 :             : #include &quot;../common/threading.h&quot;   /* mutex */</span>
<span id="L24"><span class="lineNum">      24</span>                 :             : #include &quot;zstd_compress_internal.h&quot; /* MIN, ERROR, ZSTD_*, ZSTD_highbit32 */</span>
<span id="L25"><span class="lineNum">      25</span>                 :             : #include &quot;zstd_ldm.h&quot;</span>
<span id="L26"><span class="lineNum">      26</span>                 :             : #include &quot;zstdmt_compress.h&quot;</span>
<span id="L27"><span class="lineNum">      27</span>                 :             : </span>
<span id="L28"><span class="lineNum">      28</span>                 :             : /* Guards code to support resizing the SeqPool.</span>
<span id="L29"><span class="lineNum">      29</span>                 :             :  * We will want to resize the SeqPool to save memory in the future.</span>
<span id="L30"><span class="lineNum">      30</span>                 :             :  * Until then, comment the code out since it is unused.</span>
<span id="L31"><span class="lineNum">      31</span>                 :             :  */</span>
<span id="L32"><span class="lineNum">      32</span>                 :             : #define ZSTD_RESIZE_SEQPOOL 0</span>
<span id="L33"><span class="lineNum">      33</span>                 :             : </span>
<span id="L34"><span class="lineNum">      34</span>                 :             : /* ======   Debug   ====== */</span>
<span id="L35"><span class="lineNum">      35</span>                 :             : #if defined(DEBUGLEVEL) &amp;&amp; (DEBUGLEVEL&gt;=2) \</span>
<span id="L36"><span class="lineNum">      36</span>                 :             :     &amp;&amp; !defined(_MSC_VER) \</span>
<span id="L37"><span class="lineNum">      37</span>                 :             :     &amp;&amp; !defined(__MINGW32__)</span>
<span id="L38"><span class="lineNum">      38</span>                 :             : </span>
<span id="L39"><span class="lineNum">      39</span>                 :             : #  include &lt;stdio.h&gt;</span>
<span id="L40"><span class="lineNum">      40</span>                 :             : #  include &lt;unistd.h&gt;</span>
<span id="L41"><span class="lineNum">      41</span>                 :             : #  include &lt;sys/times.h&gt;</span>
<span id="L42"><span class="lineNum">      42</span>                 :             : </span>
<span id="L43"><span class="lineNum">      43</span>                 :             : #  define DEBUG_PRINTHEX(l,p,n)                                       \</span>
<span id="L44"><span class="lineNum">      44</span>                 :             :     do {                                                              \</span>
<span id="L45"><span class="lineNum">      45</span>                 :             :         unsigned debug_u;                                             \</span>
<span id="L46"><span class="lineNum">      46</span>                 :             :         for (debug_u=0; debug_u&lt;(n); debug_u++)                       \</span>
<span id="L47"><span class="lineNum">      47</span>                 :             :             RAWLOG(l, &quot;%02X &quot;, ((const unsigned char*)(p))[debug_u]); \</span>
<span id="L48"><span class="lineNum">      48</span>                 :             :         RAWLOG(l, &quot; \n&quot;);                                             \</span>
<span id="L49"><span class="lineNum">      49</span>                 :             :     } while (0)</span>
<span id="L50"><span class="lineNum">      50</span>                 :             : </span>
<span id="L51"><span class="lineNum">      51</span>                 :             : static unsigned long long GetCurrentClockTimeMicroseconds(void)</span>
<span id="L52"><span class="lineNum">      52</span>                 :             : {</span>
<span id="L53"><span class="lineNum">      53</span>                 :             :    static clock_t _ticksPerSecond = 0;</span>
<span id="L54"><span class="lineNum">      54</span>                 :             :    if (_ticksPerSecond &lt;= 0) _ticksPerSecond = sysconf(_SC_CLK_TCK);</span>
<span id="L55"><span class="lineNum">      55</span>                 :             : </span>
<span id="L56"><span class="lineNum">      56</span>                 :             :    {   struct tms junk; clock_t newTicks = (clock_t) times(&amp;junk);</span>
<span id="L57"><span class="lineNum">      57</span>                 :             :        return ((((unsigned long long)newTicks)*(1000000))/_ticksPerSecond);</span>
<span id="L58"><span class="lineNum">      58</span>                 :             : }  }</span>
<span id="L59"><span class="lineNum">      59</span>                 :             : </span>
<span id="L60"><span class="lineNum">      60</span>                 :             : #define MUTEX_WAIT_TIME_DLEVEL 6</span>
<span id="L61"><span class="lineNum">      61</span>                 :             : #define ZSTD_PTHREAD_MUTEX_LOCK(mutex)                                                  \</span>
<span id="L62"><span class="lineNum">      62</span>                 :             :     do {                                                                                \</span>
<span id="L63"><span class="lineNum">      63</span>                 :             :         if (DEBUGLEVEL &gt;= MUTEX_WAIT_TIME_DLEVEL) {                                     \</span>
<span id="L64"><span class="lineNum">      64</span>                 :             :             unsigned long long const beforeTime = GetCurrentClockTimeMicroseconds();    \</span>
<span id="L65"><span class="lineNum">      65</span>                 :             :             ZSTD_pthread_mutex_lock(mutex);                                             \</span>
<span id="L66"><span class="lineNum">      66</span>                 :             :             {   unsigned long long const afterTime = GetCurrentClockTimeMicroseconds(); \</span>
<span id="L67"><span class="lineNum">      67</span>                 :             :                 unsigned long long const elapsedTime = (afterTime-beforeTime);          \</span>
<span id="L68"><span class="lineNum">      68</span>                 :             :                 if (elapsedTime &gt; 1000) {                                               \</span>
<span id="L69"><span class="lineNum">      69</span>                 :             :                     /* or whatever threshold you like; I'm using 1 millisecond here */  \</span>
<span id="L70"><span class="lineNum">      70</span>                 :             :                     DEBUGLOG(MUTEX_WAIT_TIME_DLEVEL,                                    \</span>
<span id="L71"><span class="lineNum">      71</span>                 :             :                         &quot;Thread took %llu microseconds to acquire mutex %s \n&quot;,         \</span>
<span id="L72"><span class="lineNum">      72</span>                 :             :                         elapsedTime, #mutex);                                           \</span>
<span id="L73"><span class="lineNum">      73</span>                 :             :             }   }                                                                       \</span>
<span id="L74"><span class="lineNum">      74</span>                 :             :         } else {                                                                        \</span>
<span id="L75"><span class="lineNum">      75</span>                 :             :             ZSTD_pthread_mutex_lock(mutex);                                             \</span>
<span id="L76"><span class="lineNum">      76</span>                 :             :         }                                                                               \</span>
<span id="L77"><span class="lineNum">      77</span>                 :             :     } while (0)</span>
<span id="L78"><span class="lineNum">      78</span>                 :             : </span>
<span id="L79"><span class="lineNum">      79</span>                 :             : #else</span>
<span id="L80"><span class="lineNum">      80</span>                 :             : </span>
<span id="L81"><span class="lineNum">      81</span>                 :             : #  define ZSTD_PTHREAD_MUTEX_LOCK(m) ZSTD_pthread_mutex_lock(m)</span>
<span id="L82"><span class="lineNum">      82</span>                 :             : #  define DEBUG_PRINTHEX(l,p,n) do { } while (0)</span>
<span id="L83"><span class="lineNum">      83</span>                 :             : </span>
<span id="L84"><span class="lineNum">      84</span>                 :             : #endif</span>
<span id="L85"><span class="lineNum">      85</span>                 :             : </span>
<span id="L86"><span class="lineNum">      86</span>                 :             : </span>
<span id="L87"><span class="lineNum">      87</span>                 :             : /* =====   Buffer Pool   ===== */</span>
<span id="L88"><span class="lineNum">      88</span>                 :             : /* a single Buffer Pool can be invoked from multiple threads in parallel */</span>
<span id="L89"><span class="lineNum">      89</span>                 :             : </span>
<span id="L90"><span class="lineNum">      90</span>                 :             : typedef struct buffer_s {</span>
<span id="L91"><span class="lineNum">      91</span>                 :             :     void* start;</span>
<span id="L92"><span class="lineNum">      92</span>                 :             :     size_t capacity;</span>
<span id="L93"><span class="lineNum">      93</span>                 :             : } Buffer;</span>
<span id="L94"><span class="lineNum">      94</span>                 :             : </span>
<span id="L95"><span class="lineNum">      95</span>                 :             : static const Buffer g_nullBuffer = { NULL, 0 };</span>
<span id="L96"><span class="lineNum">      96</span>                 :             : </span>
<span id="L97"><span class="lineNum">      97</span>                 :             : typedef struct ZSTDMT_bufferPool_s {</span>
<span id="L98"><span class="lineNum">      98</span>                 :             :     ZSTD_pthread_mutex_t poolMutex;</span>
<span id="L99"><span class="lineNum">      99</span>                 :             :     size_t bufferSize;</span>
<span id="L100"><span class="lineNum">     100</span>                 :             :     unsigned totalBuffers;</span>
<span id="L101"><span class="lineNum">     101</span>                 :             :     unsigned nbBuffers;</span>
<span id="L102"><span class="lineNum">     102</span>                 :             :     ZSTD_customMem cMem;</span>
<span id="L103"><span class="lineNum">     103</span>                 :             :     Buffer* buffers;</span>
<span id="L104"><span class="lineNum">     104</span>                 :             : } ZSTDMT_bufferPool;</span>
<span id="L105"><span class="lineNum">     105</span>                 :             : </span>
<span id="L106"><span class="lineNum">     106</span>                 :<span class="tlaUNC tlaBgUNC">           0 : static void ZSTDMT_freeBufferPool(ZSTDMT_bufferPool* bufPool)</span></span>
<span id="L107"><span class="lineNum">     107</span>                 :             : {</span>
<span id="L108"><span class="lineNum">     108</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(3, &quot;ZSTDMT_freeBufferPool (address:%08X)&quot;, (U32)(size_t)bufPool);</span></span>
<span id="L109"><span class="lineNum">     109</span>                 :<span class="tlaUNC">           0 :     if (!bufPool) return;   /* compatibility with free on NULL */</span></span>
<span id="L110"><span class="lineNum">     110</span>                 :<span class="tlaUNC">           0 :     if (bufPool-&gt;buffers) {</span></span>
<span id="L111"><span class="lineNum">     111</span>                 :             :         unsigned u;</span>
<span id="L112"><span class="lineNum">     112</span>                 :<span class="tlaUNC">           0 :         for (u=0; u&lt;bufPool-&gt;totalBuffers; u++) {</span></span>
<span id="L113"><span class="lineNum">     113</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(4, &quot;free buffer %2u (address:%08X)&quot;, u, (U32)(size_t)bufPool-&gt;buffers[u].start);</span></span>
<span id="L114"><span class="lineNum">     114</span>                 :<span class="tlaUNC">           0 :             ZSTD_customFree(bufPool-&gt;buffers[u].start, bufPool-&gt;cMem);</span></span>
<span id="L115"><span class="lineNum">     115</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L116"><span class="lineNum">     116</span>                 :<span class="tlaUNC">           0 :         ZSTD_customFree(bufPool-&gt;buffers, bufPool-&gt;cMem);</span></span>
<span id="L117"><span class="lineNum">     117</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L118"><span class="lineNum">     118</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_destroy(&amp;bufPool-&gt;poolMutex);</span></span>
<span id="L119"><span class="lineNum">     119</span>                 :<span class="tlaUNC">           0 :     ZSTD_customFree(bufPool, bufPool-&gt;cMem);</span></span>
<span id="L120"><span class="lineNum">     120</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L121"><span class="lineNum">     121</span>                 :             : </span>
<span id="L122"><span class="lineNum">     122</span>                 :<span class="tlaUNC">           0 : static ZSTDMT_bufferPool* ZSTDMT_createBufferPool(unsigned maxNbBuffers, ZSTD_customMem cMem)</span></span>
<span id="L123"><span class="lineNum">     123</span>                 :             : {</span>
<span id="L124"><span class="lineNum">     124</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_bufferPool* const bufPool =</span></span>
<span id="L125"><span class="lineNum">     125</span>                 :<span class="tlaUNC">           0 :         (ZSTDMT_bufferPool*)ZSTD_customCalloc(sizeof(ZSTDMT_bufferPool), cMem);</span></span>
<span id="L126"><span class="lineNum">     126</span>                 :<span class="tlaUNC">           0 :     if (bufPool==NULL) return NULL;</span></span>
<span id="L127"><span class="lineNum">     127</span>                 :<span class="tlaUNC">           0 :     if (ZSTD_pthread_mutex_init(&amp;bufPool-&gt;poolMutex, NULL)) {</span></span>
<span id="L128"><span class="lineNum">     128</span>                 :<span class="tlaUNC">           0 :         ZSTD_customFree(bufPool, cMem);</span></span>
<span id="L129"><span class="lineNum">     129</span>                 :<span class="tlaUNC">           0 :         return NULL;</span></span>
<span id="L130"><span class="lineNum">     130</span>                 :             :     }</span>
<span id="L131"><span class="lineNum">     131</span>                 :<span class="tlaUNC">           0 :     bufPool-&gt;buffers = (Buffer*)ZSTD_customCalloc(maxNbBuffers * sizeof(Buffer), cMem);</span></span>
<span id="L132"><span class="lineNum">     132</span>                 :<span class="tlaUNC">           0 :     if (bufPool-&gt;buffers==NULL) {</span></span>
<span id="L133"><span class="lineNum">     133</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_freeBufferPool(bufPool);</span></span>
<span id="L134"><span class="lineNum">     134</span>                 :<span class="tlaUNC">           0 :         return NULL;</span></span>
<span id="L135"><span class="lineNum">     135</span>                 :             :     }</span>
<span id="L136"><span class="lineNum">     136</span>                 :<span class="tlaUNC">           0 :     bufPool-&gt;bufferSize = 64 KB;</span></span>
<span id="L137"><span class="lineNum">     137</span>                 :<span class="tlaUNC">           0 :     bufPool-&gt;totalBuffers = maxNbBuffers;</span></span>
<span id="L138"><span class="lineNum">     138</span>                 :<span class="tlaUNC">           0 :     bufPool-&gt;nbBuffers = 0;</span></span>
<span id="L139"><span class="lineNum">     139</span>                 :<span class="tlaUNC">           0 :     bufPool-&gt;cMem = cMem;</span></span>
<span id="L140"><span class="lineNum">     140</span>                 :<span class="tlaUNC">           0 :     return bufPool;</span></span>
<span id="L141"><span class="lineNum">     141</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L142"><span class="lineNum">     142</span>                 :             : </span>
<span id="L143"><span class="lineNum">     143</span>                 :             : /* only works at initialization, not during compression */</span>
<span id="L144"><span class="lineNum">     144</span>                 :<span class="tlaUNC">           0 : static size_t ZSTDMT_sizeof_bufferPool(ZSTDMT_bufferPool* bufPool)</span></span>
<span id="L145"><span class="lineNum">     145</span>                 :             : {</span>
<span id="L146"><span class="lineNum">     146</span>                 :<span class="tlaUNC">           0 :     size_t const poolSize = sizeof(*bufPool);</span></span>
<span id="L147"><span class="lineNum">     147</span>                 :<span class="tlaUNC">           0 :     size_t const arraySize = bufPool-&gt;totalBuffers * sizeof(Buffer);</span></span>
<span id="L148"><span class="lineNum">     148</span>                 :             :     unsigned u;</span>
<span id="L149"><span class="lineNum">     149</span>                 :<span class="tlaUNC">           0 :     size_t totalBufferSize = 0;</span></span>
<span id="L150"><span class="lineNum">     150</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_lock(&amp;bufPool-&gt;poolMutex);</span></span>
<span id="L151"><span class="lineNum">     151</span>                 :<span class="tlaUNC">           0 :     for (u=0; u&lt;bufPool-&gt;totalBuffers; u++)</span></span>
<span id="L152"><span class="lineNum">     152</span>                 :<span class="tlaUNC">           0 :         totalBufferSize += bufPool-&gt;buffers[u].capacity;</span></span>
<span id="L153"><span class="lineNum">     153</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_unlock(&amp;bufPool-&gt;poolMutex);</span></span>
<span id="L154"><span class="lineNum">     154</span>                 :             : </span>
<span id="L155"><span class="lineNum">     155</span>                 :<span class="tlaUNC">           0 :     return poolSize + arraySize + totalBufferSize;</span></span>
<span id="L156"><span class="lineNum">     156</span>                 :             : }</span>
<span id="L157"><span class="lineNum">     157</span>                 :             : </span>
<span id="L158"><span class="lineNum">     158</span>                 :             : /* ZSTDMT_setBufferSize() :</span>
<span id="L159"><span class="lineNum">     159</span>                 :             :  * all future buffers provided by this buffer pool will have _at least_ this size</span>
<span id="L160"><span class="lineNum">     160</span>                 :             :  * note : it's better for all buffers to have same size,</span>
<span id="L161"><span class="lineNum">     161</span>                 :             :  * as they become freely interchangeable, reducing malloc/free usages and memory fragmentation */</span>
<span id="L162"><span class="lineNum">     162</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_setBufferSize(ZSTDMT_bufferPool* const bufPool, size_t const bSize)</span></span>
<span id="L163"><span class="lineNum">     163</span>                 :             : {</span>
<span id="L164"><span class="lineNum">     164</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_lock(&amp;bufPool-&gt;poolMutex);</span></span>
<span id="L165"><span class="lineNum">     165</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(4, &quot;ZSTDMT_setBufferSize: bSize = %u&quot;, (U32)bSize);</span></span>
<span id="L166"><span class="lineNum">     166</span>                 :<span class="tlaUNC">           0 :     bufPool-&gt;bufferSize = bSize;</span></span>
<span id="L167"><span class="lineNum">     167</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_unlock(&amp;bufPool-&gt;poolMutex);</span></span>
<span id="L168"><span class="lineNum">     168</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L169"><span class="lineNum">     169</span>                 :             : </span>
<span id="L170"><span class="lineNum">     170</span>                 :             : </span>
<span id="L171"><span class="lineNum">     171</span>                 :<span class="tlaUNC">           0 : static ZSTDMT_bufferPool* ZSTDMT_expandBufferPool(ZSTDMT_bufferPool* srcBufPool, unsigned maxNbBuffers)</span></span>
<span id="L172"><span class="lineNum">     172</span>                 :             : {</span>
<span id="L173"><span class="lineNum">     173</span>                 :<span class="tlaUNC">           0 :     if (srcBufPool==NULL) return NULL;</span></span>
<span id="L174"><span class="lineNum">     174</span>                 :<span class="tlaUNC">           0 :     if (srcBufPool-&gt;totalBuffers &gt;= maxNbBuffers) /* good enough */</span></span>
<span id="L175"><span class="lineNum">     175</span>                 :<span class="tlaUNC">           0 :         return srcBufPool;</span></span>
<span id="L176"><span class="lineNum">     176</span>                 :             :     /* need a larger buffer pool */</span>
<span id="L177"><span class="lineNum">     177</span>                 :<span class="tlaUNC">           0 :     {   ZSTD_customMem const cMem = srcBufPool-&gt;cMem;</span></span>
<span id="L178"><span class="lineNum">     178</span>                 :<span class="tlaUNC">           0 :         size_t const bSize = srcBufPool-&gt;bufferSize;   /* forward parameters */</span></span>
<span id="L179"><span class="lineNum">     179</span>                 :             :         ZSTDMT_bufferPool* newBufPool;</span>
<span id="L180"><span class="lineNum">     180</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_freeBufferPool(srcBufPool);</span></span>
<span id="L181"><span class="lineNum">     181</span>                 :<span class="tlaUNC">           0 :         newBufPool = ZSTDMT_createBufferPool(maxNbBuffers, cMem);</span></span>
<span id="L182"><span class="lineNum">     182</span>                 :<span class="tlaUNC">           0 :         if (newBufPool==NULL) return newBufPool;</span></span>
<span id="L183"><span class="lineNum">     183</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_setBufferSize(newBufPool, bSize);</span></span>
<span id="L184"><span class="lineNum">     184</span>                 :<span class="tlaUNC">           0 :         return newBufPool;</span></span>
<span id="L185"><span class="lineNum">     185</span>                 :             :     }</span>
<span id="L186"><span class="lineNum">     186</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L187"><span class="lineNum">     187</span>                 :             : </span>
<span id="L188"><span class="lineNum">     188</span>                 :             : /** ZSTDMT_getBuffer() :</span>
<span id="L189"><span class="lineNum">     189</span>                 :             :  *  assumption : bufPool must be valid</span>
<span id="L190"><span class="lineNum">     190</span>                 :             :  * @return : a buffer, with start pointer and size</span>
<span id="L191"><span class="lineNum">     191</span>                 :             :  *  note: allocation may fail, in this case, start==NULL and size==0 */</span>
<span id="L192"><span class="lineNum">     192</span>                 :<span class="tlaUNC">           0 : static Buffer ZSTDMT_getBuffer(ZSTDMT_bufferPool* bufPool)</span></span>
<span id="L193"><span class="lineNum">     193</span>                 :             : {</span>
<span id="L194"><span class="lineNum">     194</span>                 :<span class="tlaUNC">           0 :     size_t const bSize = bufPool-&gt;bufferSize;</span></span>
<span id="L195"><span class="lineNum">     195</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_getBuffer: bSize = %u&quot;, (U32)bufPool-&gt;bufferSize);</span></span>
<span id="L196"><span class="lineNum">     196</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_lock(&amp;bufPool-&gt;poolMutex);</span></span>
<span id="L197"><span class="lineNum">     197</span>                 :<span class="tlaUNC">           0 :     if (bufPool-&gt;nbBuffers) {   /* try to use an existing buffer */</span></span>
<span id="L198"><span class="lineNum">     198</span>                 :<span class="tlaUNC">           0 :         Buffer const buf = bufPool-&gt;buffers[--(bufPool-&gt;nbBuffers)];</span></span>
<span id="L199"><span class="lineNum">     199</span>                 :<span class="tlaUNC">           0 :         size_t const availBufferSize = buf.capacity;</span></span>
<span id="L200"><span class="lineNum">     200</span>                 :<span class="tlaUNC">           0 :         bufPool-&gt;buffers[bufPool-&gt;nbBuffers] = g_nullBuffer;</span></span>
<span id="L201"><span class="lineNum">     201</span>                 :<span class="tlaUNC">           0 :         if ((availBufferSize &gt;= bSize) &amp; ((availBufferSize&gt;&gt;3) &lt;= bSize)) {</span></span>
<span id="L202"><span class="lineNum">     202</span>                 :             :             /* large enough, but not too much */</span>
<span id="L203"><span class="lineNum">     203</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(5, &quot;ZSTDMT_getBuffer: provide buffer %u of size %u&quot;,</span></span>
<span id="L204"><span class="lineNum">     204</span>                 :             :                         bufPool-&gt;nbBuffers, (U32)buf.capacity);</span>
<span id="L205"><span class="lineNum">     205</span>                 :<span class="tlaUNC">           0 :             ZSTD_pthread_mutex_unlock(&amp;bufPool-&gt;poolMutex);</span></span>
<span id="L206"><span class="lineNum">     206</span>                 :<span class="tlaUNC">           0 :             return buf;</span></span>
<span id="L207"><span class="lineNum">     207</span>                 :             :         }</span>
<span id="L208"><span class="lineNum">     208</span>                 :             :         /* size conditions not respected : scratch this buffer, create new one */</span>
<span id="L209"><span class="lineNum">     209</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;ZSTDMT_getBuffer: existing buffer does not meet size conditions =&gt; freeing&quot;);</span></span>
<span id="L210"><span class="lineNum">     210</span>                 :<span class="tlaUNC">           0 :         ZSTD_customFree(buf.start, bufPool-&gt;cMem);</span></span>
<span id="L211"><span class="lineNum">     211</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L212"><span class="lineNum">     212</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_unlock(&amp;bufPool-&gt;poolMutex);</span></span>
<span id="L213"><span class="lineNum">     213</span>                 :             :     /* create new buffer */</span>
<span id="L214"><span class="lineNum">     214</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_getBuffer: create a new buffer&quot;);</span></span>
<span id="L215"><span class="lineNum">     215</span>                 :             :     {   Buffer buffer;</span>
<span id="L216"><span class="lineNum">     216</span>                 :<span class="tlaUNC">           0 :         void* const start = ZSTD_customMalloc(bSize, bufPool-&gt;cMem);</span></span>
<span id="L217"><span class="lineNum">     217</span>                 :<span class="tlaUNC">           0 :         buffer.start = start;   /* note : start can be NULL if malloc fails ! */</span></span>
<span id="L218"><span class="lineNum">     218</span>                 :<span class="tlaUNC">           0 :         buffer.capacity = (start==NULL) ? 0 : bSize;</span></span>
<span id="L219"><span class="lineNum">     219</span>                 :<span class="tlaUNC">           0 :         if (start==NULL) {</span></span>
<span id="L220"><span class="lineNum">     220</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(5, &quot;ZSTDMT_getBuffer: buffer allocation failure !!&quot;);</span></span>
<span id="L221"><span class="lineNum">     221</span>                 :<span class="tlaUNC">           0 :         } else {</span></span>
<span id="L222"><span class="lineNum">     222</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(5, &quot;ZSTDMT_getBuffer: created buffer of size %u&quot;, (U32)bSize);</span></span>
<span id="L223"><span class="lineNum">     223</span>                 :             :         }</span>
<span id="L224"><span class="lineNum">     224</span>                 :<span class="tlaUNC">           0 :         return buffer;</span></span>
<span id="L225"><span class="lineNum">     225</span>                 :             :     }</span>
<span id="L226"><span class="lineNum">     226</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L227"><span class="lineNum">     227</span>                 :             : </span>
<span id="L228"><span class="lineNum">     228</span>                 :             : #if ZSTD_RESIZE_SEQPOOL</span>
<span id="L229"><span class="lineNum">     229</span>                 :             : /** ZSTDMT_resizeBuffer() :</span>
<span id="L230"><span class="lineNum">     230</span>                 :             :  * assumption : bufPool must be valid</span>
<span id="L231"><span class="lineNum">     231</span>                 :             :  * @return : a buffer that is at least the buffer pool buffer size.</span>
<span id="L232"><span class="lineNum">     232</span>                 :             :  *           If a reallocation happens, the data in the input buffer is copied.</span>
<span id="L233"><span class="lineNum">     233</span>                 :             :  */</span>
<span id="L234"><span class="lineNum">     234</span>                 :             : static Buffer ZSTDMT_resizeBuffer(ZSTDMT_bufferPool* bufPool, Buffer buffer)</span>
<span id="L235"><span class="lineNum">     235</span>                 :             : {</span>
<span id="L236"><span class="lineNum">     236</span>                 :             :     size_t const bSize = bufPool-&gt;bufferSize;</span>
<span id="L237"><span class="lineNum">     237</span>                 :             :     if (buffer.capacity &lt; bSize) {</span>
<span id="L238"><span class="lineNum">     238</span>                 :             :         void* const start = ZSTD_customMalloc(bSize, bufPool-&gt;cMem);</span>
<span id="L239"><span class="lineNum">     239</span>                 :             :         Buffer newBuffer;</span>
<span id="L240"><span class="lineNum">     240</span>                 :             :         newBuffer.start = start;</span>
<span id="L241"><span class="lineNum">     241</span>                 :             :         newBuffer.capacity = start == NULL ? 0 : bSize;</span>
<span id="L242"><span class="lineNum">     242</span>                 :             :         if (start != NULL) {</span>
<span id="L243"><span class="lineNum">     243</span>                 :             :             assert(newBuffer.capacity &gt;= buffer.capacity);</span>
<span id="L244"><span class="lineNum">     244</span>                 :             :             ZSTD_memcpy(newBuffer.start, buffer.start, buffer.capacity);</span>
<span id="L245"><span class="lineNum">     245</span>                 :             :             DEBUGLOG(5, &quot;ZSTDMT_resizeBuffer: created buffer of size %u&quot;, (U32)bSize);</span>
<span id="L246"><span class="lineNum">     246</span>                 :             :             return newBuffer;</span>
<span id="L247"><span class="lineNum">     247</span>                 :             :         }</span>
<span id="L248"><span class="lineNum">     248</span>                 :             :         DEBUGLOG(5, &quot;ZSTDMT_resizeBuffer: buffer allocation failure !!&quot;);</span>
<span id="L249"><span class="lineNum">     249</span>                 :             :     }</span>
<span id="L250"><span class="lineNum">     250</span>                 :             :     return buffer;</span>
<span id="L251"><span class="lineNum">     251</span>                 :             : }</span>
<span id="L252"><span class="lineNum">     252</span>                 :             : #endif</span>
<span id="L253"><span class="lineNum">     253</span>                 :             : </span>
<span id="L254"><span class="lineNum">     254</span>                 :             : /* store buffer for later re-use, up to pool capacity */</span>
<span id="L255"><span class="lineNum">     255</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_releaseBuffer(ZSTDMT_bufferPool* bufPool, Buffer buf)</span></span>
<span id="L256"><span class="lineNum">     256</span>                 :             : {</span>
<span id="L257"><span class="lineNum">     257</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_releaseBuffer&quot;);</span></span>
<span id="L258"><span class="lineNum">     258</span>                 :<span class="tlaUNC">           0 :     if (buf.start == NULL) return;   /* compatible with release on NULL */</span></span>
<span id="L259"><span class="lineNum">     259</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_lock(&amp;bufPool-&gt;poolMutex);</span></span>
<span id="L260"><span class="lineNum">     260</span>                 :<span class="tlaUNC">           0 :     if (bufPool-&gt;nbBuffers &lt; bufPool-&gt;totalBuffers) {</span></span>
<span id="L261"><span class="lineNum">     261</span>                 :<span class="tlaUNC">           0 :         bufPool-&gt;buffers[bufPool-&gt;nbBuffers++] = buf;  /* stored for later use */</span></span>
<span id="L262"><span class="lineNum">     262</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;ZSTDMT_releaseBuffer: stored buffer of size %u in slot %u&quot;,</span></span>
<span id="L263"><span class="lineNum">     263</span>                 :             :                     (U32)buf.capacity, (U32)(bufPool-&gt;nbBuffers-1));</span>
<span id="L264"><span class="lineNum">     264</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_mutex_unlock(&amp;bufPool-&gt;poolMutex);</span></span>
<span id="L265"><span class="lineNum">     265</span>                 :<span class="tlaUNC">           0 :         return;</span></span>
<span id="L266"><span class="lineNum">     266</span>                 :             :     }</span>
<span id="L267"><span class="lineNum">     267</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_unlock(&amp;bufPool-&gt;poolMutex);</span></span>
<span id="L268"><span class="lineNum">     268</span>                 :             :     /* Reached bufferPool capacity (note: should not happen) */</span>
<span id="L269"><span class="lineNum">     269</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_releaseBuffer: pool capacity reached =&gt; freeing &quot;);</span></span>
<span id="L270"><span class="lineNum">     270</span>                 :<span class="tlaUNC">           0 :     ZSTD_customFree(buf.start, bufPool-&gt;cMem);</span></span>
<span id="L271"><span class="lineNum">     271</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L272"><span class="lineNum">     272</span>                 :             : </span>
<span id="L273"><span class="lineNum">     273</span>                 :             : /* We need 2 output buffers per worker since each dstBuff must be flushed after it is released.</span>
<span id="L274"><span class="lineNum">     274</span>                 :             :  * The 3 additional buffers are as follows:</span>
<span id="L275"><span class="lineNum">     275</span>                 :             :  *   1 buffer for input loading</span>
<span id="L276"><span class="lineNum">     276</span>                 :             :  *   1 buffer for &quot;next input&quot; when submitting current one</span>
<span id="L277"><span class="lineNum">     277</span>                 :             :  *   1 buffer stuck in queue */</span>
<span id="L278"><span class="lineNum">     278</span>                 :             : #define BUF_POOL_MAX_NB_BUFFERS(nbWorkers) (2*(nbWorkers) + 3)</span>
<span id="L279"><span class="lineNum">     279</span>                 :             : </span>
<span id="L280"><span class="lineNum">     280</span>                 :             : /* After a worker releases its rawSeqStore, it is immediately ready for reuse.</span>
<span id="L281"><span class="lineNum">     281</span>                 :             :  * So we only need one seq buffer per worker. */</span>
<span id="L282"><span class="lineNum">     282</span>                 :             : #define SEQ_POOL_MAX_NB_BUFFERS(nbWorkers) (nbWorkers)</span>
<span id="L283"><span class="lineNum">     283</span>                 :             : </span>
<span id="L284"><span class="lineNum">     284</span>                 :             : /* =====   Seq Pool Wrapper   ====== */</span>
<span id="L285"><span class="lineNum">     285</span>                 :             : </span>
<span id="L286"><span class="lineNum">     286</span>                 :             : typedef ZSTDMT_bufferPool ZSTDMT_seqPool;</span>
<span id="L287"><span class="lineNum">     287</span>                 :             : </span>
<span id="L288"><span class="lineNum">     288</span>                 :<span class="tlaUNC">           0 : static size_t ZSTDMT_sizeof_seqPool(ZSTDMT_seqPool* seqPool)</span></span>
<span id="L289"><span class="lineNum">     289</span>                 :             : {</span>
<span id="L290"><span class="lineNum">     290</span>                 :<span class="tlaUNC">           0 :     return ZSTDMT_sizeof_bufferPool(seqPool);</span></span>
<span id="L291"><span class="lineNum">     291</span>                 :             : }</span>
<span id="L292"><span class="lineNum">     292</span>                 :             : </span>
<span id="L293"><span class="lineNum">     293</span>                 :<span class="tlaUNC">           0 : static RawSeqStore_t bufferToSeq(Buffer buffer)</span></span>
<span id="L294"><span class="lineNum">     294</span>                 :             : {</span>
<span id="L295"><span class="lineNum">     295</span>                 :<span class="tlaUNC">           0 :     RawSeqStore_t seq = kNullRawSeqStore;</span></span>
<span id="L296"><span class="lineNum">     296</span>                 :<span class="tlaUNC">           0 :     seq.seq = (rawSeq*)buffer.start;</span></span>
<span id="L297"><span class="lineNum">     297</span>                 :<span class="tlaUNC">           0 :     seq.capacity = buffer.capacity / sizeof(rawSeq);</span></span>
<span id="L298"><span class="lineNum">     298</span>                 :<span class="tlaUNC">           0 :     return seq;</span></span>
<span id="L299"><span class="lineNum">     299</span>                 :             : }</span>
<span id="L300"><span class="lineNum">     300</span>                 :             : </span>
<span id="L301"><span class="lineNum">     301</span>                 :<span class="tlaUNC">           0 : static Buffer seqToBuffer(RawSeqStore_t seq)</span></span>
<span id="L302"><span class="lineNum">     302</span>                 :             : {</span>
<span id="L303"><span class="lineNum">     303</span>                 :             :     Buffer buffer;</span>
<span id="L304"><span class="lineNum">     304</span>                 :<span class="tlaUNC">           0 :     buffer.start = seq.seq;</span></span>
<span id="L305"><span class="lineNum">     305</span>                 :<span class="tlaUNC">           0 :     buffer.capacity = seq.capacity * sizeof(rawSeq);</span></span>
<span id="L306"><span class="lineNum">     306</span>                 :<span class="tlaUNC">           0 :     return buffer;</span></span>
<span id="L307"><span class="lineNum">     307</span>                 :             : }</span>
<span id="L308"><span class="lineNum">     308</span>                 :             : </span>
<span id="L309"><span class="lineNum">     309</span>                 :<span class="tlaUNC">           0 : static RawSeqStore_t ZSTDMT_getSeq(ZSTDMT_seqPool* seqPool)</span></span>
<span id="L310"><span class="lineNum">     310</span>                 :             : {</span>
<span id="L311"><span class="lineNum">     311</span>                 :<span class="tlaUNC">           0 :     if (seqPool-&gt;bufferSize == 0) {</span></span>
<span id="L312"><span class="lineNum">     312</span>                 :<span class="tlaUNC">           0 :         return kNullRawSeqStore;</span></span>
<span id="L313"><span class="lineNum">     313</span>                 :             :     }</span>
<span id="L314"><span class="lineNum">     314</span>                 :<span class="tlaUNC">           0 :     return bufferToSeq(ZSTDMT_getBuffer(seqPool));</span></span>
<span id="L315"><span class="lineNum">     315</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L316"><span class="lineNum">     316</span>                 :             : </span>
<span id="L317"><span class="lineNum">     317</span>                 :             : #if ZSTD_RESIZE_SEQPOOL</span>
<span id="L318"><span class="lineNum">     318</span>                 :             : static RawSeqStore_t ZSTDMT_resizeSeq(ZSTDMT_seqPool* seqPool, RawSeqStore_t seq)</span>
<span id="L319"><span class="lineNum">     319</span>                 :             : {</span>
<span id="L320"><span class="lineNum">     320</span>                 :             :   return bufferToSeq(ZSTDMT_resizeBuffer(seqPool, seqToBuffer(seq)));</span>
<span id="L321"><span class="lineNum">     321</span>                 :             : }</span>
<span id="L322"><span class="lineNum">     322</span>                 :             : #endif</span>
<span id="L323"><span class="lineNum">     323</span>                 :             : </span>
<span id="L324"><span class="lineNum">     324</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_releaseSeq(ZSTDMT_seqPool* seqPool, RawSeqStore_t seq)</span></span>
<span id="L325"><span class="lineNum">     325</span>                 :             : {</span>
<span id="L326"><span class="lineNum">     326</span>                 :<span class="tlaUNC">           0 :   ZSTDMT_releaseBuffer(seqPool, seqToBuffer(seq));</span></span>
<span id="L327"><span class="lineNum">     327</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L328"><span class="lineNum">     328</span>                 :             : </span>
<span id="L329"><span class="lineNum">     329</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_setNbSeq(ZSTDMT_seqPool* const seqPool, size_t const nbSeq)</span></span>
<span id="L330"><span class="lineNum">     330</span>                 :             : {</span>
<span id="L331"><span class="lineNum">     331</span>                 :<span class="tlaUNC">           0 :   ZSTDMT_setBufferSize(seqPool, nbSeq * sizeof(rawSeq));</span></span>
<span id="L332"><span class="lineNum">     332</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L333"><span class="lineNum">     333</span>                 :             : </span>
<span id="L334"><span class="lineNum">     334</span>                 :             : static ZSTDMT_seqPool* ZSTDMT_createSeqPool(unsigned nbWorkers, ZSTD_customMem cMem)</span>
<span id="L335"><span class="lineNum">     335</span>                 :             : {</span>
<span id="L336"><span class="lineNum">     336</span>                 :             :     ZSTDMT_seqPool* const seqPool = ZSTDMT_createBufferPool(SEQ_POOL_MAX_NB_BUFFERS(nbWorkers), cMem);</span>
<span id="L337"><span class="lineNum">     337</span>                 :             :     if (seqPool == NULL) return NULL;</span>
<span id="L338"><span class="lineNum">     338</span>                 :             :     ZSTDMT_setNbSeq(seqPool, 0);</span>
<span id="L339"><span class="lineNum">     339</span>                 :             :     return seqPool;</span>
<span id="L340"><span class="lineNum">     340</span>                 :             : }</span>
<span id="L341"><span class="lineNum">     341</span>                 :             : </span>
<span id="L342"><span class="lineNum">     342</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_freeSeqPool(ZSTDMT_seqPool* seqPool)</span></span>
<span id="L343"><span class="lineNum">     343</span>                 :             : {</span>
<span id="L344"><span class="lineNum">     344</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_freeBufferPool(seqPool);</span></span>
<span id="L345"><span class="lineNum">     345</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L346"><span class="lineNum">     346</span>                 :             : </span>
<span id="L347"><span class="lineNum">     347</span>                 :<span class="tlaUNC">           0 : static ZSTDMT_seqPool* ZSTDMT_expandSeqPool(ZSTDMT_seqPool* pool, U32 nbWorkers)</span></span>
<span id="L348"><span class="lineNum">     348</span>                 :             : {</span>
<span id="L349"><span class="lineNum">     349</span>                 :<span class="tlaUNC">           0 :     return ZSTDMT_expandBufferPool(pool, SEQ_POOL_MAX_NB_BUFFERS(nbWorkers));</span></span>
<span id="L350"><span class="lineNum">     350</span>                 :             : }</span>
<span id="L351"><span class="lineNum">     351</span>                 :             : </span>
<span id="L352"><span class="lineNum">     352</span>                 :             : </span>
<span id="L353"><span class="lineNum">     353</span>                 :             : /* =====   CCtx Pool   ===== */</span>
<span id="L354"><span class="lineNum">     354</span>                 :             : /* a single CCtx Pool can be invoked from multiple threads in parallel */</span>
<span id="L355"><span class="lineNum">     355</span>                 :             : </span>
<span id="L356"><span class="lineNum">     356</span>                 :             : typedef struct {</span>
<span id="L357"><span class="lineNum">     357</span>                 :             :     ZSTD_pthread_mutex_t poolMutex;</span>
<span id="L358"><span class="lineNum">     358</span>                 :             :     int totalCCtx;</span>
<span id="L359"><span class="lineNum">     359</span>                 :             :     int availCCtx;</span>
<span id="L360"><span class="lineNum">     360</span>                 :             :     ZSTD_customMem cMem;</span>
<span id="L361"><span class="lineNum">     361</span>                 :             :     ZSTD_CCtx** cctxs;</span>
<span id="L362"><span class="lineNum">     362</span>                 :             : } ZSTDMT_CCtxPool;</span>
<span id="L363"><span class="lineNum">     363</span>                 :             : </span>
<span id="L364"><span class="lineNum">     364</span>                 :             : /* note : all CCtx borrowed from the pool must be reverted back to the pool _before_ freeing the pool */</span>
<span id="L365"><span class="lineNum">     365</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_freeCCtxPool(ZSTDMT_CCtxPool* pool)</span></span>
<span id="L366"><span class="lineNum">     366</span>                 :             : {</span>
<span id="L367"><span class="lineNum">     367</span>                 :<span class="tlaUNC">           0 :     if (!pool) return;</span></span>
<span id="L368"><span class="lineNum">     368</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_destroy(&amp;pool-&gt;poolMutex);</span></span>
<span id="L369"><span class="lineNum">     369</span>                 :<span class="tlaUNC">           0 :     if (pool-&gt;cctxs) {</span></span>
<span id="L370"><span class="lineNum">     370</span>                 :             :         int cid;</span>
<span id="L371"><span class="lineNum">     371</span>                 :<span class="tlaUNC">           0 :         for (cid=0; cid&lt;pool-&gt;totalCCtx; cid++)</span></span>
<span id="L372"><span class="lineNum">     372</span>                 :<span class="tlaUNC">           0 :             ZSTD_freeCCtx(pool-&gt;cctxs[cid]);  /* free compatible with NULL */</span></span>
<span id="L373"><span class="lineNum">     373</span>                 :<span class="tlaUNC">           0 :         ZSTD_customFree(pool-&gt;cctxs, pool-&gt;cMem);</span></span>
<span id="L374"><span class="lineNum">     374</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L375"><span class="lineNum">     375</span>                 :<span class="tlaUNC">           0 :     ZSTD_customFree(pool, pool-&gt;cMem);</span></span>
<span id="L376"><span class="lineNum">     376</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L377"><span class="lineNum">     377</span>                 :             : </span>
<span id="L378"><span class="lineNum">     378</span>                 :             : /* ZSTDMT_createCCtxPool() :</span>
<span id="L379"><span class="lineNum">     379</span>                 :             :  * implies nbWorkers &gt;= 1 , checked by caller ZSTDMT_createCCtx() */</span>
<span id="L380"><span class="lineNum">     380</span>                 :<span class="tlaUNC">           0 : static ZSTDMT_CCtxPool* ZSTDMT_createCCtxPool(int nbWorkers,</span></span>
<span id="L381"><span class="lineNum">     381</span>                 :             :                                               ZSTD_customMem cMem)</span>
<span id="L382"><span class="lineNum">     382</span>                 :             : {</span>
<span id="L383"><span class="lineNum">     383</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_CCtxPool* const cctxPool =</span></span>
<span id="L384"><span class="lineNum">     384</span>                 :<span class="tlaUNC">           0 :         (ZSTDMT_CCtxPool*) ZSTD_customCalloc(sizeof(ZSTDMT_CCtxPool), cMem);</span></span>
<span id="L385"><span class="lineNum">     385</span>                 :             :     assert(nbWorkers &gt; 0);</span>
<span id="L386"><span class="lineNum">     386</span>                 :<span class="tlaUNC">           0 :     if (!cctxPool) return NULL;</span></span>
<span id="L387"><span class="lineNum">     387</span>                 :<span class="tlaUNC">           0 :     if (ZSTD_pthread_mutex_init(&amp;cctxPool-&gt;poolMutex, NULL)) {</span></span>
<span id="L388"><span class="lineNum">     388</span>                 :<span class="tlaUNC">           0 :         ZSTD_customFree(cctxPool, cMem);</span></span>
<span id="L389"><span class="lineNum">     389</span>                 :<span class="tlaUNC">           0 :         return NULL;</span></span>
<span id="L390"><span class="lineNum">     390</span>                 :             :     }</span>
<span id="L391"><span class="lineNum">     391</span>                 :<span class="tlaUNC">           0 :     cctxPool-&gt;totalCCtx = nbWorkers;</span></span>
<span id="L392"><span class="lineNum">     392</span>                 :<span class="tlaUNC">           0 :     cctxPool-&gt;cctxs = (ZSTD_CCtx**)ZSTD_customCalloc(nbWorkers * sizeof(ZSTD_CCtx*), cMem);</span></span>
<span id="L393"><span class="lineNum">     393</span>                 :<span class="tlaUNC">           0 :     if (!cctxPool-&gt;cctxs) {</span></span>
<span id="L394"><span class="lineNum">     394</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_freeCCtxPool(cctxPool);</span></span>
<span id="L395"><span class="lineNum">     395</span>                 :<span class="tlaUNC">           0 :         return NULL;</span></span>
<span id="L396"><span class="lineNum">     396</span>                 :             :     }</span>
<span id="L397"><span class="lineNum">     397</span>                 :<span class="tlaUNC">           0 :     cctxPool-&gt;cMem = cMem;</span></span>
<span id="L398"><span class="lineNum">     398</span>                 :<span class="tlaUNC">           0 :     cctxPool-&gt;cctxs[0] = ZSTD_createCCtx_advanced(cMem);</span></span>
<span id="L399"><span class="lineNum">     399</span>                 :<span class="tlaUNC">           0 :     if (!cctxPool-&gt;cctxs[0]) { ZSTDMT_freeCCtxPool(cctxPool); return NULL; }</span></span>
<span id="L400"><span class="lineNum">     400</span>                 :<span class="tlaUNC">           0 :     cctxPool-&gt;availCCtx = 1;   /* at least one cctx for single-thread mode */</span></span>
<span id="L401"><span class="lineNum">     401</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(3, &quot;cctxPool created, with %u workers&quot;, nbWorkers);</span></span>
<span id="L402"><span class="lineNum">     402</span>                 :<span class="tlaUNC">           0 :     return cctxPool;</span></span>
<span id="L403"><span class="lineNum">     403</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L404"><span class="lineNum">     404</span>                 :             : </span>
<span id="L405"><span class="lineNum">     405</span>                 :<span class="tlaUNC">           0 : static ZSTDMT_CCtxPool* ZSTDMT_expandCCtxPool(ZSTDMT_CCtxPool* srcPool,</span></span>
<span id="L406"><span class="lineNum">     406</span>                 :             :                                               int nbWorkers)</span>
<span id="L407"><span class="lineNum">     407</span>                 :             : {</span>
<span id="L408"><span class="lineNum">     408</span>                 :<span class="tlaUNC">           0 :     if (srcPool==NULL) return NULL;</span></span>
<span id="L409"><span class="lineNum">     409</span>                 :<span class="tlaUNC">           0 :     if (nbWorkers &lt;= srcPool-&gt;totalCCtx) return srcPool;   /* good enough */</span></span>
<span id="L410"><span class="lineNum">     410</span>                 :             :     /* need a larger cctx pool */</span>
<span id="L411"><span class="lineNum">     411</span>                 :<span class="tlaUNC">           0 :     {   ZSTD_customMem const cMem = srcPool-&gt;cMem;</span></span>
<span id="L412"><span class="lineNum">     412</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_freeCCtxPool(srcPool);</span></span>
<span id="L413"><span class="lineNum">     413</span>                 :<span class="tlaUNC">           0 :         return ZSTDMT_createCCtxPool(nbWorkers, cMem);</span></span>
<span id="L414"><span class="lineNum">     414</span>                 :             :     }</span>
<span id="L415"><span class="lineNum">     415</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L416"><span class="lineNum">     416</span>                 :             : </span>
<span id="L417"><span class="lineNum">     417</span>                 :             : /* only works during initialization phase, not during compression */</span>
<span id="L418"><span class="lineNum">     418</span>                 :<span class="tlaUNC">           0 : static size_t ZSTDMT_sizeof_CCtxPool(ZSTDMT_CCtxPool* cctxPool)</span></span>
<span id="L419"><span class="lineNum">     419</span>                 :             : {</span>
<span id="L420"><span class="lineNum">     420</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_lock(&amp;cctxPool-&gt;poolMutex);</span></span>
<span id="L421"><span class="lineNum">     421</span>                 :<span class="tlaUNC">           0 :     {   unsigned const nbWorkers = cctxPool-&gt;totalCCtx;</span></span>
<span id="L422"><span class="lineNum">     422</span>                 :<span class="tlaUNC">           0 :         size_t const poolSize = sizeof(*cctxPool);</span></span>
<span id="L423"><span class="lineNum">     423</span>                 :<span class="tlaUNC">           0 :         size_t const arraySize = cctxPool-&gt;totalCCtx * sizeof(ZSTD_CCtx*);</span></span>
<span id="L424"><span class="lineNum">     424</span>                 :<span class="tlaUNC">           0 :         size_t totalCCtxSize = 0;</span></span>
<span id="L425"><span class="lineNum">     425</span>                 :             :         unsigned u;</span>
<span id="L426"><span class="lineNum">     426</span>                 :<span class="tlaUNC">           0 :         for (u=0; u&lt;nbWorkers; u++) {</span></span>
<span id="L427"><span class="lineNum">     427</span>                 :<span class="tlaUNC">           0 :             totalCCtxSize += ZSTD_sizeof_CCtx(cctxPool-&gt;cctxs[u]);</span></span>
<span id="L428"><span class="lineNum">     428</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L429"><span class="lineNum">     429</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_mutex_unlock(&amp;cctxPool-&gt;poolMutex);</span></span>
<span id="L430"><span class="lineNum">     430</span>                 :             :         assert(nbWorkers &gt; 0);</span>
<span id="L431"><span class="lineNum">     431</span>                 :<span class="tlaUNC">           0 :         return poolSize + arraySize + totalCCtxSize;</span></span>
<span id="L432"><span class="lineNum">     432</span>                 :             :     }</span>
<span id="L433"><span class="lineNum">     433</span>                 :             : }</span>
<span id="L434"><span class="lineNum">     434</span>                 :             : </span>
<span id="L435"><span class="lineNum">     435</span>                 :<span class="tlaUNC">           0 : static ZSTD_CCtx* ZSTDMT_getCCtx(ZSTDMT_CCtxPool* cctxPool)</span></span>
<span id="L436"><span class="lineNum">     436</span>                 :             : {</span>
<span id="L437"><span class="lineNum">     437</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_getCCtx&quot;);</span></span>
<span id="L438"><span class="lineNum">     438</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_lock(&amp;cctxPool-&gt;poolMutex);</span></span>
<span id="L439"><span class="lineNum">     439</span>                 :<span class="tlaUNC">           0 :     if (cctxPool-&gt;availCCtx) {</span></span>
<span id="L440"><span class="lineNum">     440</span>                 :<span class="tlaUNC">           0 :         cctxPool-&gt;availCCtx--;</span></span>
<span id="L441"><span class="lineNum">     441</span>                 :<span class="tlaUNC">           0 :         {   ZSTD_CCtx* const cctx = cctxPool-&gt;cctxs[cctxPool-&gt;availCCtx];</span></span>
<span id="L442"><span class="lineNum">     442</span>                 :<span class="tlaUNC">           0 :             ZSTD_pthread_mutex_unlock(&amp;cctxPool-&gt;poolMutex);</span></span>
<span id="L443"><span class="lineNum">     443</span>                 :<span class="tlaUNC">           0 :             return cctx;</span></span>
<span id="L444"><span class="lineNum">     444</span>                 :             :     }   }</span>
<span id="L445"><span class="lineNum">     445</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_unlock(&amp;cctxPool-&gt;poolMutex);</span></span>
<span id="L446"><span class="lineNum">     446</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;create one more CCtx&quot;);</span></span>
<span id="L447"><span class="lineNum">     447</span>                 :<span class="tlaUNC">           0 :     return ZSTD_createCCtx_advanced(cctxPool-&gt;cMem);   /* note : can be NULL, when creation fails ! */</span></span>
<span id="L448"><span class="lineNum">     448</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L449"><span class="lineNum">     449</span>                 :             : </span>
<span id="L450"><span class="lineNum">     450</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_releaseCCtx(ZSTDMT_CCtxPool* pool, ZSTD_CCtx* cctx)</span></span>
<span id="L451"><span class="lineNum">     451</span>                 :             : {</span>
<span id="L452"><span class="lineNum">     452</span>                 :<span class="tlaUNC">           0 :     if (cctx==NULL) return;   /* compatibility with release on NULL */</span></span>
<span id="L453"><span class="lineNum">     453</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_lock(&amp;pool-&gt;poolMutex);</span></span>
<span id="L454"><span class="lineNum">     454</span>                 :<span class="tlaUNC">           0 :     if (pool-&gt;availCCtx &lt; pool-&gt;totalCCtx)</span></span>
<span id="L455"><span class="lineNum">     455</span>                 :<span class="tlaUNC">           0 :         pool-&gt;cctxs[pool-&gt;availCCtx++] = cctx;</span></span>
<span id="L456"><span class="lineNum">     456</span>                 :             :     else {</span>
<span id="L457"><span class="lineNum">     457</span>                 :             :         /* pool overflow : should not happen, since totalCCtx==nbWorkers */</span>
<span id="L458"><span class="lineNum">     458</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(4, &quot;CCtx pool overflow : free cctx&quot;);</span></span>
<span id="L459"><span class="lineNum">     459</span>                 :<span class="tlaUNC">           0 :         ZSTD_freeCCtx(cctx);</span></span>
<span id="L460"><span class="lineNum">     460</span>                 :             :     }</span>
<span id="L461"><span class="lineNum">     461</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_unlock(&amp;pool-&gt;poolMutex);</span></span>
<span id="L462"><span class="lineNum">     462</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L463"><span class="lineNum">     463</span>                 :             : </span>
<span id="L464"><span class="lineNum">     464</span>                 :             : /* ====   Serial State   ==== */</span>
<span id="L465"><span class="lineNum">     465</span>                 :             : </span>
<span id="L466"><span class="lineNum">     466</span>                 :             : typedef struct {</span>
<span id="L467"><span class="lineNum">     467</span>                 :             :     void const* start;</span>
<span id="L468"><span class="lineNum">     468</span>                 :             :     size_t size;</span>
<span id="L469"><span class="lineNum">     469</span>                 :             : } Range;</span>
<span id="L470"><span class="lineNum">     470</span>                 :             : </span>
<span id="L471"><span class="lineNum">     471</span>                 :             : typedef struct {</span>
<span id="L472"><span class="lineNum">     472</span>                 :             :     /* All variables in the struct are protected by mutex. */</span>
<span id="L473"><span class="lineNum">     473</span>                 :             :     ZSTD_pthread_mutex_t mutex;</span>
<span id="L474"><span class="lineNum">     474</span>                 :             :     ZSTD_pthread_cond_t cond;</span>
<span id="L475"><span class="lineNum">     475</span>                 :             :     ZSTD_CCtx_params params;</span>
<span id="L476"><span class="lineNum">     476</span>                 :             :     ldmState_t ldmState;</span>
<span id="L477"><span class="lineNum">     477</span>                 :             :     XXH64_state_t xxhState;</span>
<span id="L478"><span class="lineNum">     478</span>                 :             :     unsigned nextJobID;</span>
<span id="L479"><span class="lineNum">     479</span>                 :             :     /* Protects ldmWindow.</span>
<span id="L480"><span class="lineNum">     480</span>                 :             :      * Must be acquired after the main mutex when acquiring both.</span>
<span id="L481"><span class="lineNum">     481</span>                 :             :      */</span>
<span id="L482"><span class="lineNum">     482</span>                 :             :     ZSTD_pthread_mutex_t ldmWindowMutex;</span>
<span id="L483"><span class="lineNum">     483</span>                 :             :     ZSTD_pthread_cond_t ldmWindowCond;  /* Signaled when ldmWindow is updated */</span>
<span id="L484"><span class="lineNum">     484</span>                 :             :     ZSTD_window_t ldmWindow;  /* A thread-safe copy of ldmState.window */</span>
<span id="L485"><span class="lineNum">     485</span>                 :             : } SerialState;</span>
<span id="L486"><span class="lineNum">     486</span>                 :             : </span>
<span id="L487"><span class="lineNum">     487</span>                 :             : static int</span>
<span id="L488"><span class="lineNum">     488</span>                 :<span class="tlaUNC">           0 : ZSTDMT_serialState_reset(SerialState* serialState,</span></span>
<span id="L489"><span class="lineNum">     489</span>                 :             :                          ZSTDMT_seqPool* seqPool,</span>
<span id="L490"><span class="lineNum">     490</span>                 :             :                          ZSTD_CCtx_params params,</span>
<span id="L491"><span class="lineNum">     491</span>                 :             :                          size_t jobSize,</span>
<span id="L492"><span class="lineNum">     492</span>                 :             :                          const void* dict, size_t const dictSize,</span>
<span id="L493"><span class="lineNum">     493</span>                 :             :                          ZSTD_dictContentType_e dictContentType)</span>
<span id="L494"><span class="lineNum">     494</span>                 :             : {</span>
<span id="L495"><span class="lineNum">     495</span>                 :             :     /* Adjust parameters */</span>
<span id="L496"><span class="lineNum">     496</span>                 :<span class="tlaUNC">           0 :     if (params.ldmParams.enableLdm == ZSTD_ps_enable) {</span></span>
<span id="L497"><span class="lineNum">     497</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(4, &quot;LDM window size = %u KB&quot;, (1U &lt;&lt; params.cParams.windowLog) &gt;&gt; 10);</span></span>
<span id="L498"><span class="lineNum">     498</span>                 :<span class="tlaUNC">           0 :         ZSTD_ldm_adjustParameters(&amp;params.ldmParams, &amp;params.cParams);</span></span>
<span id="L499"><span class="lineNum">     499</span>                 :             :         assert(params.ldmParams.hashLog &gt;= params.ldmParams.bucketSizeLog);</span>
<span id="L500"><span class="lineNum">     500</span>                 :             :         assert(params.ldmParams.hashRateLog &lt; 32);</span>
<span id="L501"><span class="lineNum">     501</span>                 :<span class="tlaUNC">           0 :     } else {</span></span>
<span id="L502"><span class="lineNum">     502</span>                 :<span class="tlaUNC">           0 :         ZSTD_memset(&amp;params.ldmParams, 0, sizeof(params.ldmParams));</span></span>
<span id="L503"><span class="lineNum">     503</span>                 :             :     }</span>
<span id="L504"><span class="lineNum">     504</span>                 :<span class="tlaUNC">           0 :     serialState-&gt;nextJobID = 0;</span></span>
<span id="L505"><span class="lineNum">     505</span>                 :<span class="tlaUNC">           0 :     if (params.fParams.checksumFlag)</span></span>
<span id="L506"><span class="lineNum">     506</span>                 :<span class="tlaUNC">           0 :         XXH64_reset(&amp;serialState-&gt;xxhState, 0);</span></span>
<span id="L507"><span class="lineNum">     507</span>                 :<span class="tlaUNC">           0 :     if (params.ldmParams.enableLdm == ZSTD_ps_enable) {</span></span>
<span id="L508"><span class="lineNum">     508</span>                 :<span class="tlaUNC">           0 :         ZSTD_customMem cMem = params.customMem;</span></span>
<span id="L509"><span class="lineNum">     509</span>                 :<span class="tlaUNC">           0 :         unsigned const hashLog = params.ldmParams.hashLog;</span></span>
<span id="L510"><span class="lineNum">     510</span>                 :<span class="tlaUNC">           0 :         size_t const hashSize = ((size_t)1 &lt;&lt; hashLog) * sizeof(ldmEntry_t);</span></span>
<span id="L511"><span class="lineNum">     511</span>                 :<span class="tlaUNC">           0 :         unsigned const bucketLog =</span></span>
<span id="L512"><span class="lineNum">     512</span>                 :<span class="tlaUNC">           0 :             params.ldmParams.hashLog - params.ldmParams.bucketSizeLog;</span></span>
<span id="L513"><span class="lineNum">     513</span>                 :<span class="tlaUNC">           0 :         unsigned const prevBucketLog =</span></span>
<span id="L514"><span class="lineNum">     514</span>                 :<span class="tlaUNC">           0 :             serialState-&gt;params.ldmParams.hashLog -</span></span>
<span id="L515"><span class="lineNum">     515</span>                 :<span class="tlaUNC">           0 :             serialState-&gt;params.ldmParams.bucketSizeLog;</span></span>
<span id="L516"><span class="lineNum">     516</span>                 :<span class="tlaUNC">           0 :         size_t const numBuckets = (size_t)1 &lt;&lt; bucketLog;</span></span>
<span id="L517"><span class="lineNum">     517</span>                 :             :         /* Size the seq pool tables */</span>
<span id="L518"><span class="lineNum">     518</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_setNbSeq(seqPool, ZSTD_ldm_getMaxNbSeq(params.ldmParams, jobSize));</span></span>
<span id="L519"><span class="lineNum">     519</span>                 :             :         /* Reset the window */</span>
<span id="L520"><span class="lineNum">     520</span>                 :<span class="tlaUNC">           0 :         ZSTD_window_init(&amp;serialState-&gt;ldmState.window);</span></span>
<span id="L521"><span class="lineNum">     521</span>                 :             :         /* Resize tables and output space if necessary. */</span>
<span id="L522"><span class="lineNum">     522</span>                 :<span class="tlaUNC">           0 :         if (serialState-&gt;ldmState.hashTable == NULL || serialState-&gt;params.ldmParams.hashLog &lt; hashLog) {</span></span>
<span id="L523"><span class="lineNum">     523</span>                 :<span class="tlaUNC">           0 :             ZSTD_customFree(serialState-&gt;ldmState.hashTable, cMem);</span></span>
<span id="L524"><span class="lineNum">     524</span>                 :<span class="tlaUNC">           0 :             serialState-&gt;ldmState.hashTable = (ldmEntry_t*)ZSTD_customMalloc(hashSize, cMem);</span></span>
<span id="L525"><span class="lineNum">     525</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L526"><span class="lineNum">     526</span>                 :<span class="tlaUNC">           0 :         if (serialState-&gt;ldmState.bucketOffsets == NULL || prevBucketLog &lt; bucketLog) {</span></span>
<span id="L527"><span class="lineNum">     527</span>                 :<span class="tlaUNC">           0 :             ZSTD_customFree(serialState-&gt;ldmState.bucketOffsets, cMem);</span></span>
<span id="L528"><span class="lineNum">     528</span>                 :<span class="tlaUNC">           0 :             serialState-&gt;ldmState.bucketOffsets = (BYTE*)ZSTD_customMalloc(numBuckets, cMem);</span></span>
<span id="L529"><span class="lineNum">     529</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L530"><span class="lineNum">     530</span>                 :<span class="tlaUNC">           0 :         if (!serialState-&gt;ldmState.hashTable || !serialState-&gt;ldmState.bucketOffsets)</span></span>
<span id="L531"><span class="lineNum">     531</span>                 :<span class="tlaUNC">           0 :             return 1;</span></span>
<span id="L532"><span class="lineNum">     532</span>                 :             :         /* Zero the tables */</span>
<span id="L533"><span class="lineNum">     533</span>                 :<span class="tlaUNC">           0 :         ZSTD_memset(serialState-&gt;ldmState.hashTable, 0, hashSize);</span></span>
<span id="L534"><span class="lineNum">     534</span>                 :<span class="tlaUNC">           0 :         ZSTD_memset(serialState-&gt;ldmState.bucketOffsets, 0, numBuckets);</span></span>
<span id="L535"><span class="lineNum">     535</span>                 :             : </span>
<span id="L536"><span class="lineNum">     536</span>                 :             :         /* Update window state and fill hash table with dict */</span>
<span id="L537"><span class="lineNum">     537</span>                 :<span class="tlaUNC">           0 :         serialState-&gt;ldmState.loadedDictEnd = 0;</span></span>
<span id="L538"><span class="lineNum">     538</span>                 :<span class="tlaUNC">           0 :         if (dictSize &gt; 0) {</span></span>
<span id="L539"><span class="lineNum">     539</span>                 :<span class="tlaUNC">           0 :             if (dictContentType == ZSTD_dct_rawContent) {</span></span>
<span id="L540"><span class="lineNum">     540</span>                 :<span class="tlaUNC">           0 :                 BYTE const* const dictEnd = (const BYTE*)dict + dictSize;</span></span>
<span id="L541"><span class="lineNum">     541</span>                 :<span class="tlaUNC">           0 :                 ZSTD_window_update(&amp;serialState-&gt;ldmState.window, dict, dictSize, /* forceNonContiguous */ 0);</span></span>
<span id="L542"><span class="lineNum">     542</span>                 :<span class="tlaUNC">           0 :                 ZSTD_ldm_fillHashTable(&amp;serialState-&gt;ldmState, (const BYTE*)dict, dictEnd, &amp;params.ldmParams);</span></span>
<span id="L543"><span class="lineNum">     543</span>                 :<span class="tlaUNC">           0 :                 serialState-&gt;ldmState.loadedDictEnd = params.forceWindow ? 0 : (U32)(dictEnd - serialState-&gt;ldmState.window.base);</span></span>
<span id="L544"><span class="lineNum">     544</span>                 :<span class="tlaUNC">           0 :             } else {</span></span>
<span id="L545"><span class="lineNum">     545</span>                 :             :                 /* don't even load anything */</span>
<span id="L546"><span class="lineNum">     546</span>                 :             :             }</span>
<span id="L547"><span class="lineNum">     547</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L548"><span class="lineNum">     548</span>                 :             : </span>
<span id="L549"><span class="lineNum">     549</span>                 :             :         /* Initialize serialState's copy of ldmWindow. */</span>
<span id="L550"><span class="lineNum">     550</span>                 :<span class="tlaUNC">           0 :         serialState-&gt;ldmWindow = serialState-&gt;ldmState.window;</span></span>
<span id="L551"><span class="lineNum">     551</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L552"><span class="lineNum">     552</span>                 :             : </span>
<span id="L553"><span class="lineNum">     553</span>                 :<span class="tlaUNC">           0 :     serialState-&gt;params = params;</span></span>
<span id="L554"><span class="lineNum">     554</span>                 :<span class="tlaUNC">           0 :     serialState-&gt;params.jobSize = (U32)jobSize;</span></span>
<span id="L555"><span class="lineNum">     555</span>                 :<span class="tlaUNC">           0 :     return 0;</span></span>
<span id="L556"><span class="lineNum">     556</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L557"><span class="lineNum">     557</span>                 :             : </span>
<span id="L558"><span class="lineNum">     558</span>                 :             : static int ZSTDMT_serialState_init(SerialState* serialState)</span>
<span id="L559"><span class="lineNum">     559</span>                 :             : {</span>
<span id="L560"><span class="lineNum">     560</span>                 :             :     int initError = 0;</span>
<span id="L561"><span class="lineNum">     561</span>                 :             :     ZSTD_memset(serialState, 0, sizeof(*serialState));</span>
<span id="L562"><span class="lineNum">     562</span>                 :             :     initError |= ZSTD_pthread_mutex_init(&amp;serialState-&gt;mutex, NULL);</span>
<span id="L563"><span class="lineNum">     563</span>                 :             :     initError |= ZSTD_pthread_cond_init(&amp;serialState-&gt;cond, NULL);</span>
<span id="L564"><span class="lineNum">     564</span>                 :             :     initError |= ZSTD_pthread_mutex_init(&amp;serialState-&gt;ldmWindowMutex, NULL);</span>
<span id="L565"><span class="lineNum">     565</span>                 :             :     initError |= ZSTD_pthread_cond_init(&amp;serialState-&gt;ldmWindowCond, NULL);</span>
<span id="L566"><span class="lineNum">     566</span>                 :             :     return initError;</span>
<span id="L567"><span class="lineNum">     567</span>                 :             : }</span>
<span id="L568"><span class="lineNum">     568</span>                 :             : </span>
<span id="L569"><span class="lineNum">     569</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_serialState_free(SerialState* serialState)</span></span>
<span id="L570"><span class="lineNum">     570</span>                 :             : {</span>
<span id="L571"><span class="lineNum">     571</span>                 :<span class="tlaUNC">           0 :     ZSTD_customMem cMem = serialState-&gt;params.customMem;</span></span>
<span id="L572"><span class="lineNum">     572</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_destroy(&amp;serialState-&gt;mutex);</span></span>
<span id="L573"><span class="lineNum">     573</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_cond_destroy(&amp;serialState-&gt;cond);</span></span>
<span id="L574"><span class="lineNum">     574</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_destroy(&amp;serialState-&gt;ldmWindowMutex);</span></span>
<span id="L575"><span class="lineNum">     575</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_cond_destroy(&amp;serialState-&gt;ldmWindowCond);</span></span>
<span id="L576"><span class="lineNum">     576</span>                 :<span class="tlaUNC">           0 :     ZSTD_customFree(serialState-&gt;ldmState.hashTable, cMem);</span></span>
<span id="L577"><span class="lineNum">     577</span>                 :<span class="tlaUNC">           0 :     ZSTD_customFree(serialState-&gt;ldmState.bucketOffsets, cMem);</span></span>
<span id="L578"><span class="lineNum">     578</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L579"><span class="lineNum">     579</span>                 :             : </span>
<span id="L580"><span class="lineNum">     580</span>                 :             : static void</span>
<span id="L581"><span class="lineNum">     581</span>                 :<span class="tlaUNC">           0 : ZSTDMT_serialState_genSequences(SerialState* serialState,</span></span>
<span id="L582"><span class="lineNum">     582</span>                 :             :                                 RawSeqStore_t* seqStore,</span>
<span id="L583"><span class="lineNum">     583</span>                 :             :                                 Range src, unsigned jobID)</span>
<span id="L584"><span class="lineNum">     584</span>                 :             : {</span>
<span id="L585"><span class="lineNum">     585</span>                 :             :     /* Wait for our turn */</span>
<span id="L586"><span class="lineNum">     586</span>                 :<span class="tlaUNC">           0 :     ZSTD_PTHREAD_MUTEX_LOCK(&amp;serialState-&gt;mutex);</span></span>
<span id="L587"><span class="lineNum">     587</span>                 :<span class="tlaUNC">           0 :     while (serialState-&gt;nextJobID &lt; jobID) {</span></span>
<span id="L588"><span class="lineNum">     588</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;wait for serialState-&gt;cond&quot;);</span></span>
<span id="L589"><span class="lineNum">     589</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_cond_wait(&amp;serialState-&gt;cond, &amp;serialState-&gt;mutex);</span></span>
<span id="L590"><span class="lineNum">     590</span>                 :             :     }</span>
<span id="L591"><span class="lineNum">     591</span>                 :             :     /* A future job may error and skip our job */</span>
<span id="L592"><span class="lineNum">     592</span>                 :<span class="tlaUNC">           0 :     if (serialState-&gt;nextJobID == jobID) {</span></span>
<span id="L593"><span class="lineNum">     593</span>                 :             :         /* It is now our turn, do any processing necessary */</span>
<span id="L594"><span class="lineNum">     594</span>                 :<span class="tlaUNC">           0 :         if (serialState-&gt;params.ldmParams.enableLdm == ZSTD_ps_enable) {</span></span>
<span id="L595"><span class="lineNum">     595</span>                 :             :             size_t error;</span>
<span id="L596"><span class="lineNum">     596</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(6, &quot;ZSTDMT_serialState_genSequences: LDM update&quot;);</span></span>
<span id="L597"><span class="lineNum">     597</span>                 :             :             assert(seqStore-&gt;seq != NULL &amp;&amp; seqStore-&gt;pos == 0 &amp;&amp;</span>
<span id="L598"><span class="lineNum">     598</span>                 :             :                    seqStore-&gt;size == 0 &amp;&amp; seqStore-&gt;capacity &gt; 0);</span>
<span id="L599"><span class="lineNum">     599</span>                 :             :             assert(src.size &lt;= serialState-&gt;params.jobSize);</span>
<span id="L600"><span class="lineNum">     600</span>                 :<span class="tlaUNC">           0 :             ZSTD_window_update(&amp;serialState-&gt;ldmState.window, src.start, src.size, /* forceNonContiguous */ 0);</span></span>
<span id="L601"><span class="lineNum">     601</span>                 :<span class="tlaUNC">           0 :             error = ZSTD_ldm_generateSequences(</span></span>
<span id="L602"><span class="lineNum">     602</span>                 :<span class="tlaUNC">           0 :                 &amp;serialState-&gt;ldmState, seqStore,</span></span>
<span id="L603"><span class="lineNum">     603</span>                 :<span class="tlaUNC">           0 :                 &amp;serialState-&gt;params.ldmParams, src.start, src.size);</span></span>
<span id="L604"><span class="lineNum">     604</span>                 :             :             /* We provide a large enough buffer to never fail. */</span>
<span id="L605"><span class="lineNum">     605</span>                 :<span class="tlaUNC">           0 :             assert(!ZSTD_isError(error)); (void)error;</span></span>
<span id="L606"><span class="lineNum">     606</span>                 :             :             /* Update ldmWindow to match the ldmState.window and signal the main</span>
<span id="L607"><span class="lineNum">     607</span>                 :             :              * thread if it is waiting for a buffer.</span>
<span id="L608"><span class="lineNum">     608</span>                 :             :              */</span>
<span id="L609"><span class="lineNum">     609</span>                 :<span class="tlaUNC">           0 :             ZSTD_PTHREAD_MUTEX_LOCK(&amp;serialState-&gt;ldmWindowMutex);</span></span>
<span id="L610"><span class="lineNum">     610</span>                 :<span class="tlaUNC">           0 :             serialState-&gt;ldmWindow = serialState-&gt;ldmState.window;</span></span>
<span id="L611"><span class="lineNum">     611</span>                 :<span class="tlaUNC">           0 :             ZSTD_pthread_cond_signal(&amp;serialState-&gt;ldmWindowCond);</span></span>
<span id="L612"><span class="lineNum">     612</span>                 :<span class="tlaUNC">           0 :             ZSTD_pthread_mutex_unlock(&amp;serialState-&gt;ldmWindowMutex);</span></span>
<span id="L613"><span class="lineNum">     613</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L614"><span class="lineNum">     614</span>                 :<span class="tlaUNC">           0 :         if (serialState-&gt;params.fParams.checksumFlag &amp;&amp; src.size &gt; 0)</span></span>
<span id="L615"><span class="lineNum">     615</span>                 :<span class="tlaUNC">           0 :             XXH64_update(&amp;serialState-&gt;xxhState, src.start, src.size);</span></span>
<span id="L616"><span class="lineNum">     616</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L617"><span class="lineNum">     617</span>                 :             :     /* Now it is the next jobs turn */</span>
<span id="L618"><span class="lineNum">     618</span>                 :<span class="tlaUNC">           0 :     serialState-&gt;nextJobID++;</span></span>
<span id="L619"><span class="lineNum">     619</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_cond_broadcast(&amp;serialState-&gt;cond);</span></span>
<span id="L620"><span class="lineNum">     620</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_unlock(&amp;serialState-&gt;mutex);</span></span>
<span id="L621"><span class="lineNum">     621</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L622"><span class="lineNum">     622</span>                 :             : </span>
<span id="L623"><span class="lineNum">     623</span>                 :             : static void</span>
<span id="L624"><span class="lineNum">     624</span>                 :<span class="tlaUNC">           0 : ZSTDMT_serialState_applySequences(const SerialState* serialState, /* just for an assert() check */</span></span>
<span id="L625"><span class="lineNum">     625</span>                 :             :                                   ZSTD_CCtx* jobCCtx,</span>
<span id="L626"><span class="lineNum">     626</span>                 :             :                                   const RawSeqStore_t* seqStore)</span>
<span id="L627"><span class="lineNum">     627</span>                 :             : {</span>
<span id="L628"><span class="lineNum">     628</span>                 :<span class="tlaUNC">           0 :     if (seqStore-&gt;size &gt; 0) {</span></span>
<span id="L629"><span class="lineNum">     629</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;ZSTDMT_serialState_applySequences: uploading %u external sequences&quot;, (unsigned)seqStore-&gt;size);</span></span>
<span id="L630"><span class="lineNum">     630</span>                 :<span class="tlaUNC">           0 :         assert(serialState-&gt;params.ldmParams.enableLdm == ZSTD_ps_enable); (void)serialState;</span></span>
<span id="L631"><span class="lineNum">     631</span>                 :             :         assert(jobCCtx);</span>
<span id="L632"><span class="lineNum">     632</span>                 :<span class="tlaUNC">           0 :         ZSTD_referenceExternalSequences(jobCCtx, seqStore-&gt;seq, seqStore-&gt;size);</span></span>
<span id="L633"><span class="lineNum">     633</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L634"><span class="lineNum">     634</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L635"><span class="lineNum">     635</span>                 :             : </span>
<span id="L636"><span class="lineNum">     636</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_serialState_ensureFinished(SerialState* serialState,</span></span>
<span id="L637"><span class="lineNum">     637</span>                 :             :                                               unsigned jobID, size_t cSize)</span>
<span id="L638"><span class="lineNum">     638</span>                 :             : {</span>
<span id="L639"><span class="lineNum">     639</span>                 :<span class="tlaUNC">           0 :     ZSTD_PTHREAD_MUTEX_LOCK(&amp;serialState-&gt;mutex);</span></span>
<span id="L640"><span class="lineNum">     640</span>                 :<span class="tlaUNC">           0 :     if (serialState-&gt;nextJobID &lt;= jobID) {</span></span>
<span id="L641"><span class="lineNum">     641</span>                 :<span class="tlaUNC">           0 :         assert(ZSTD_isError(cSize)); (void)cSize;</span></span>
<span id="L642"><span class="lineNum">     642</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;Skipping past job %u because of error&quot;, jobID);</span></span>
<span id="L643"><span class="lineNum">     643</span>                 :<span class="tlaUNC">           0 :         serialState-&gt;nextJobID = jobID + 1;</span></span>
<span id="L644"><span class="lineNum">     644</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_cond_broadcast(&amp;serialState-&gt;cond);</span></span>
<span id="L645"><span class="lineNum">     645</span>                 :             : </span>
<span id="L646"><span class="lineNum">     646</span>                 :<span class="tlaUNC">           0 :         ZSTD_PTHREAD_MUTEX_LOCK(&amp;serialState-&gt;ldmWindowMutex);</span></span>
<span id="L647"><span class="lineNum">     647</span>                 :<span class="tlaUNC">           0 :         ZSTD_window_clear(&amp;serialState-&gt;ldmWindow);</span></span>
<span id="L648"><span class="lineNum">     648</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_cond_signal(&amp;serialState-&gt;ldmWindowCond);</span></span>
<span id="L649"><span class="lineNum">     649</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_mutex_unlock(&amp;serialState-&gt;ldmWindowMutex);</span></span>
<span id="L650"><span class="lineNum">     650</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L651"><span class="lineNum">     651</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_unlock(&amp;serialState-&gt;mutex);</span></span>
<span id="L652"><span class="lineNum">     652</span>                 :             : </span>
<span id="L653"><span class="lineNum">     653</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L654"><span class="lineNum">     654</span>                 :             : </span>
<span id="L655"><span class="lineNum">     655</span>                 :             : </span>
<span id="L656"><span class="lineNum">     656</span>                 :             : /* ------------------------------------------ */</span>
<span id="L657"><span class="lineNum">     657</span>                 :             : /* =====          Worker thread         ===== */</span>
<span id="L658"><span class="lineNum">     658</span>                 :             : /* ------------------------------------------ */</span>
<span id="L659"><span class="lineNum">     659</span>                 :             : </span>
<span id="L660"><span class="lineNum">     660</span>                 :             : static const Range kNullRange = { NULL, 0 };</span>
<span id="L661"><span class="lineNum">     661</span>                 :             : </span>
<span id="L662"><span class="lineNum">     662</span>                 :             : typedef struct {</span>
<span id="L663"><span class="lineNum">     663</span>                 :             :     size_t   consumed;                 /* SHARED - set0 by mtctx, then modified by worker AND read by mtctx */</span>
<span id="L664"><span class="lineNum">     664</span>                 :             :     size_t   cSize;                    /* SHARED - set0 by mtctx, then modified by worker AND read by mtctx, then set0 by mtctx */</span>
<span id="L665"><span class="lineNum">     665</span>                 :             :     ZSTD_pthread_mutex_t job_mutex;    /* Thread-safe - used by mtctx and worker */</span>
<span id="L666"><span class="lineNum">     666</span>                 :             :     ZSTD_pthread_cond_t job_cond;      /* Thread-safe - used by mtctx and worker */</span>
<span id="L667"><span class="lineNum">     667</span>                 :             :     ZSTDMT_CCtxPool* cctxPool;         /* Thread-safe - used by mtctx and (all) workers */</span>
<span id="L668"><span class="lineNum">     668</span>                 :             :     ZSTDMT_bufferPool* bufPool;        /* Thread-safe - used by mtctx and (all) workers */</span>
<span id="L669"><span class="lineNum">     669</span>                 :             :     ZSTDMT_seqPool* seqPool;           /* Thread-safe - used by mtctx and (all) workers */</span>
<span id="L670"><span class="lineNum">     670</span>                 :             :     SerialState* serial;               /* Thread-safe - used by mtctx and (all) workers */</span>
<span id="L671"><span class="lineNum">     671</span>                 :             :     Buffer dstBuff;                    /* set by worker (or mtctx), then read by worker &amp; mtctx, then modified by mtctx =&gt; no barrier */</span>
<span id="L672"><span class="lineNum">     672</span>                 :             :     Range prefix;                      /* set by mtctx, then read by worker &amp; mtctx =&gt; no barrier */</span>
<span id="L673"><span class="lineNum">     673</span>                 :             :     Range src;                         /* set by mtctx, then read by worker &amp; mtctx =&gt; no barrier */</span>
<span id="L674"><span class="lineNum">     674</span>                 :             :     unsigned jobID;                    /* set by mtctx, then read by worker =&gt; no barrier */</span>
<span id="L675"><span class="lineNum">     675</span>                 :             :     unsigned firstJob;                 /* set by mtctx, then read by worker =&gt; no barrier */</span>
<span id="L676"><span class="lineNum">     676</span>                 :             :     unsigned lastJob;                  /* set by mtctx, then read by worker =&gt; no barrier */</span>
<span id="L677"><span class="lineNum">     677</span>                 :             :     ZSTD_CCtx_params params;           /* set by mtctx, then read by worker =&gt; no barrier */</span>
<span id="L678"><span class="lineNum">     678</span>                 :             :     const ZSTD_CDict* cdict;           /* set by mtctx, then read by worker =&gt; no barrier */</span>
<span id="L679"><span class="lineNum">     679</span>                 :             :     unsigned long long fullFrameSize;  /* set by mtctx, then read by worker =&gt; no barrier */</span>
<span id="L680"><span class="lineNum">     680</span>                 :             :     size_t   dstFlushed;               /* used only by mtctx */</span>
<span id="L681"><span class="lineNum">     681</span>                 :             :     unsigned frameChecksumNeeded;      /* used only by mtctx */</span>
<span id="L682"><span class="lineNum">     682</span>                 :             : } ZSTDMT_jobDescription;</span>
<span id="L683"><span class="lineNum">     683</span>                 :             : </span>
<span id="L684"><span class="lineNum">     684</span>                 :             : #define JOB_ERROR(e)                                \</span>
<span id="L685"><span class="lineNum">     685</span>                 :             :     do {                                            \</span>
<span id="L686"><span class="lineNum">     686</span>                 :             :         ZSTD_PTHREAD_MUTEX_LOCK(&amp;job-&gt;job_mutex);   \</span>
<span id="L687"><span class="lineNum">     687</span>                 :             :         job-&gt;cSize = e;                             \</span>
<span id="L688"><span class="lineNum">     688</span>                 :             :         ZSTD_pthread_mutex_unlock(&amp;job-&gt;job_mutex); \</span>
<span id="L689"><span class="lineNum">     689</span>                 :             :         goto _endJob;                               \</span>
<span id="L690"><span class="lineNum">     690</span>                 :             :     } while (0)</span>
<span id="L691"><span class="lineNum">     691</span>                 :             : </span>
<span id="L692"><span class="lineNum">     692</span>                 :             : /* ZSTDMT_compressionJob() is a POOL_function type */</span>
<span id="L693"><span class="lineNum">     693</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_compressionJob(void* jobDescription)</span></span>
<span id="L694"><span class="lineNum">     694</span>                 :             : {</span>
<span id="L695"><span class="lineNum">     695</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_jobDescription* const job = (ZSTDMT_jobDescription*)jobDescription;</span></span>
<span id="L696"><span class="lineNum">     696</span>                 :<span class="tlaUNC">           0 :     ZSTD_CCtx_params jobParams = job-&gt;params;   /* do not modify job-&gt;params ! copy it, modify the copy */</span></span>
<span id="L697"><span class="lineNum">     697</span>                 :<span class="tlaUNC">           0 :     ZSTD_CCtx* const cctx = ZSTDMT_getCCtx(job-&gt;cctxPool);</span></span>
<span id="L698"><span class="lineNum">     698</span>                 :<span class="tlaUNC">           0 :     RawSeqStore_t rawSeqStore = ZSTDMT_getSeq(job-&gt;seqPool);</span></span>
<span id="L699"><span class="lineNum">     699</span>                 :<span class="tlaUNC">           0 :     Buffer dstBuff = job-&gt;dstBuff;</span></span>
<span id="L700"><span class="lineNum">     700</span>                 :<span class="tlaUNC">           0 :     size_t lastCBlockSize = 0;</span></span>
<span id="L701"><span class="lineNum">     701</span>                 :             : </span>
<span id="L702"><span class="lineNum">     702</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_compressionJob: job %u&quot;, job-&gt;jobID);</span></span>
<span id="L703"><span class="lineNum">     703</span>                 :             :     /* resources */</span>
<span id="L704"><span class="lineNum">     704</span>                 :<span class="tlaUNC">           0 :     if (cctx==NULL) JOB_ERROR(ERROR(memory_allocation));</span></span>
<span id="L705"><span class="lineNum">     705</span>                 :<span class="tlaUNC">           0 :     if (dstBuff.start == NULL) {   /* streaming job : doesn't provide a dstBuffer */</span></span>
<span id="L706"><span class="lineNum">     706</span>                 :<span class="tlaUNC">           0 :         dstBuff = ZSTDMT_getBuffer(job-&gt;bufPool);</span></span>
<span id="L707"><span class="lineNum">     707</span>                 :<span class="tlaUNC">           0 :         if (dstBuff.start==NULL) JOB_ERROR(ERROR(memory_allocation));</span></span>
<span id="L708"><span class="lineNum">     708</span>                 :<span class="tlaUNC">           0 :         job-&gt;dstBuff = dstBuff;   /* this value can be read in ZSTDMT_flush, when it copies the whole job */</span></span>
<span id="L709"><span class="lineNum">     709</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L710"><span class="lineNum">     710</span>                 :<span class="tlaUNC">           0 :     if (jobParams.ldmParams.enableLdm == ZSTD_ps_enable &amp;&amp; rawSeqStore.seq == NULL)</span></span>
<span id="L711"><span class="lineNum">     711</span>                 :<span class="tlaUNC">           0 :         JOB_ERROR(ERROR(memory_allocation));</span></span>
<span id="L712"><span class="lineNum">     712</span>                 :             : </span>
<span id="L713"><span class="lineNum">     713</span>                 :             :     /* Don't compute the checksum for chunks, since we compute it externally,</span>
<span id="L714"><span class="lineNum">     714</span>                 :             :      * but write it in the header.</span>
<span id="L715"><span class="lineNum">     715</span>                 :             :      */</span>
<span id="L716"><span class="lineNum">     716</span>                 :<span class="tlaUNC">           0 :     if (job-&gt;jobID != 0) jobParams.fParams.checksumFlag = 0;</span></span>
<span id="L717"><span class="lineNum">     717</span>                 :             :     /* Don't run LDM for the chunks, since we handle it externally */</span>
<span id="L718"><span class="lineNum">     718</span>                 :<span class="tlaUNC">           0 :     jobParams.ldmParams.enableLdm = ZSTD_ps_disable;</span></span>
<span id="L719"><span class="lineNum">     719</span>                 :             :     /* Correct nbWorkers to 0. */</span>
<span id="L720"><span class="lineNum">     720</span>                 :<span class="tlaUNC">           0 :     jobParams.nbWorkers = 0;</span></span>
<span id="L721"><span class="lineNum">     721</span>                 :             : </span>
<span id="L722"><span class="lineNum">     722</span>                 :             : </span>
<span id="L723"><span class="lineNum">     723</span>                 :             :     /* init */</span>
<span id="L724"><span class="lineNum">     724</span>                 :             : </span>
<span id="L725"><span class="lineNum">     725</span>                 :             :     /* Perform serial step as early as possible */</span>
<span id="L726"><span class="lineNum">     726</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_serialState_genSequences(job-&gt;serial, &amp;rawSeqStore, job-&gt;src, job-&gt;jobID);</span></span>
<span id="L727"><span class="lineNum">     727</span>                 :             : </span>
<span id="L728"><span class="lineNum">     728</span>                 :<span class="tlaUNC">           0 :     if (job-&gt;cdict) {</span></span>
<span id="L729"><span class="lineNum">     729</span>                 :<span class="tlaUNC">           0 :         size_t const initError = ZSTD_compressBegin_advanced_internal(cctx, NULL, 0, ZSTD_dct_auto, ZSTD_dtlm_fast, job-&gt;cdict, &amp;jobParams, job-&gt;fullFrameSize);</span></span>
<span id="L730"><span class="lineNum">     730</span>                 :             :         assert(job-&gt;firstJob);  /* only allowed for first job */</span>
<span id="L731"><span class="lineNum">     731</span>                 :<span class="tlaUNC">           0 :         if (ZSTD_isError(initError)) JOB_ERROR(initError);</span></span>
<span id="L732"><span class="lineNum">     732</span>                 :<span class="tlaUNC">           0 :     } else {</span></span>
<span id="L733"><span class="lineNum">     733</span>                 :<span class="tlaUNC">           0 :         U64 const pledgedSrcSize = job-&gt;firstJob ? job-&gt;fullFrameSize : job-&gt;src.size;</span></span>
<span id="L734"><span class="lineNum">     734</span>                 :<span class="tlaUNC">           0 :         {   size_t const forceWindowError = ZSTD_CCtxParams_setParameter(&amp;jobParams, ZSTD_c_forceMaxWindow, !job-&gt;firstJob);</span></span>
<span id="L735"><span class="lineNum">     735</span>                 :<span class="tlaUNC">           0 :             if (ZSTD_isError(forceWindowError)) JOB_ERROR(forceWindowError);</span></span>
<span id="L736"><span class="lineNum">     736</span>                 :             :         }</span>
<span id="L737"><span class="lineNum">     737</span>                 :<span class="tlaUNC">           0 :         if (!job-&gt;firstJob) {</span></span>
<span id="L738"><span class="lineNum">     738</span>                 :<span class="tlaUNC">           0 :             size_t const err = ZSTD_CCtxParams_setParameter(&amp;jobParams, ZSTD_c_deterministicRefPrefix, 0);</span></span>
<span id="L739"><span class="lineNum">     739</span>                 :<span class="tlaUNC">           0 :             if (ZSTD_isError(err)) JOB_ERROR(err);</span></span>
<span id="L740"><span class="lineNum">     740</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L741"><span class="lineNum">     741</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(6, &quot;ZSTDMT_compressionJob: job %u: loading prefix of size %zu&quot;, job-&gt;jobID, job-&gt;prefix.size);</span></span>
<span id="L742"><span class="lineNum">     742</span>                 :<span class="tlaUNC">           0 :         {   size_t const initError = ZSTD_compressBegin_advanced_internal(cctx,</span></span>
<span id="L743"><span class="lineNum">     743</span>                 :<span class="tlaUNC">           0 :                                         job-&gt;prefix.start, job-&gt;prefix.size, ZSTD_dct_rawContent,</span></span>
<span id="L744"><span class="lineNum">     744</span>                 :             :                                         ZSTD_dtlm_fast,</span>
<span id="L745"><span class="lineNum">     745</span>                 :             :                                         NULL, /*cdict*/</span>
<span id="L746"><span class="lineNum">     746</span>                 :<span class="tlaUNC">           0 :                                         &amp;jobParams, pledgedSrcSize);</span></span>
<span id="L747"><span class="lineNum">     747</span>                 :<span class="tlaUNC">           0 :             if (ZSTD_isError(initError)) JOB_ERROR(initError);</span></span>
<span id="L748"><span class="lineNum">     748</span>                 :             :     }   }</span>
<span id="L749"><span class="lineNum">     749</span>                 :             : </span>
<span id="L750"><span class="lineNum">     750</span>                 :             :     /* External Sequences can only be applied after CCtx initialization */</span>
<span id="L751"><span class="lineNum">     751</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_serialState_applySequences(job-&gt;serial, cctx, &amp;rawSeqStore);</span></span>
<span id="L752"><span class="lineNum">     752</span>                 :             : </span>
<span id="L753"><span class="lineNum">     753</span>                 :<span class="tlaUNC">           0 :     if (!job-&gt;firstJob) {  /* flush and overwrite frame header when it's not first job */</span></span>
<span id="L754"><span class="lineNum">     754</span>                 :<span class="tlaUNC">           0 :         size_t const hSize = ZSTD_compressContinue_public(cctx, dstBuff.start, dstBuff.capacity, job-&gt;src.start, 0);</span></span>
<span id="L755"><span class="lineNum">     755</span>                 :<span class="tlaUNC">           0 :         if (ZSTD_isError(hSize)) JOB_ERROR(hSize);</span></span>
<span id="L756"><span class="lineNum">     756</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;ZSTDMT_compressionJob: flush and overwrite %u bytes of frame header (not first job)&quot;, (U32)hSize);</span></span>
<span id="L757"><span class="lineNum">     757</span>                 :<span class="tlaUNC">           0 :         ZSTD_invalidateRepCodes(cctx);</span></span>
<span id="L758"><span class="lineNum">     758</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L759"><span class="lineNum">     759</span>                 :             : </span>
<span id="L760"><span class="lineNum">     760</span>                 :             :     /* compress the entire job by smaller chunks, for better granularity */</span>
<span id="L761"><span class="lineNum">     761</span>                 :<span class="tlaUNC">           0 :     {   size_t const chunkSize = 4*ZSTD_BLOCKSIZE_MAX;</span></span>
<span id="L762"><span class="lineNum">     762</span>                 :<span class="tlaUNC">           0 :         int const nbChunks = (int)((job-&gt;src.size + (chunkSize-1)) / chunkSize);</span></span>
<span id="L763"><span class="lineNum">     763</span>                 :<span class="tlaUNC">           0 :         const BYTE* ip = (const BYTE*) job-&gt;src.start;</span></span>
<span id="L764"><span class="lineNum">     764</span>                 :<span class="tlaUNC">           0 :         BYTE* const ostart = (BYTE*)dstBuff.start;</span></span>
<span id="L765"><span class="lineNum">     765</span>                 :<span class="tlaUNC">           0 :         BYTE* op = ostart;</span></span>
<span id="L766"><span class="lineNum">     766</span>                 :<span class="tlaUNC">           0 :         BYTE* oend = op + dstBuff.capacity;</span></span>
<span id="L767"><span class="lineNum">     767</span>                 :             :         int chunkNb;</span>
<span id="L768"><span class="lineNum">     768</span>                 :             :         if (sizeof(size_t) &gt; sizeof(int)) assert(job-&gt;src.size &lt; ((size_t)INT_MAX) * chunkSize);   /* check overflow */</span>
<span id="L769"><span class="lineNum">     769</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;ZSTDMT_compressionJob: compress %u bytes in %i blocks&quot;, (U32)job-&gt;src.size, nbChunks);</span></span>
<span id="L770"><span class="lineNum">     770</span>                 :             :         assert(job-&gt;cSize == 0);</span>
<span id="L771"><span class="lineNum">     771</span>                 :<span class="tlaUNC">           0 :         for (chunkNb = 1; chunkNb &lt; nbChunks; chunkNb++) {</span></span>
<span id="L772"><span class="lineNum">     772</span>                 :<span class="tlaUNC">           0 :             size_t const cSize = ZSTD_compressContinue_public(cctx, op, oend-op, ip, chunkSize);</span></span>
<span id="L773"><span class="lineNum">     773</span>                 :<span class="tlaUNC">           0 :             if (ZSTD_isError(cSize)) JOB_ERROR(cSize);</span></span>
<span id="L774"><span class="lineNum">     774</span>                 :<span class="tlaUNC">           0 :             ip += chunkSize;</span></span>
<span id="L775"><span class="lineNum">     775</span>                 :<span class="tlaUNC">           0 :             op += cSize; assert(op &lt; oend);</span></span>
<span id="L776"><span class="lineNum">     776</span>                 :             :             /* stats */</span>
<span id="L777"><span class="lineNum">     777</span>                 :<span class="tlaUNC">           0 :             ZSTD_PTHREAD_MUTEX_LOCK(&amp;job-&gt;job_mutex);</span></span>
<span id="L778"><span class="lineNum">     778</span>                 :<span class="tlaUNC">           0 :             job-&gt;cSize += cSize;</span></span>
<span id="L779"><span class="lineNum">     779</span>                 :<span class="tlaUNC">           0 :             job-&gt;consumed = chunkSize * chunkNb;</span></span>
<span id="L780"><span class="lineNum">     780</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(5, &quot;ZSTDMT_compressionJob: compress new block : cSize==%u bytes (total: %u)&quot;,</span></span>
<span id="L781"><span class="lineNum">     781</span>                 :             :                         (U32)cSize, (U32)job-&gt;cSize);</span>
<span id="L782"><span class="lineNum">     782</span>                 :<span class="tlaUNC">           0 :             ZSTD_pthread_cond_signal(&amp;job-&gt;job_cond);   /* warns some more data is ready to be flushed */</span></span>
<span id="L783"><span class="lineNum">     783</span>                 :<span class="tlaUNC">           0 :             ZSTD_pthread_mutex_unlock(&amp;job-&gt;job_mutex);</span></span>
<span id="L784"><span class="lineNum">     784</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L785"><span class="lineNum">     785</span>                 :             :         /* last block */</span>
<span id="L786"><span class="lineNum">     786</span>                 :             :         assert(chunkSize &gt; 0);</span>
<span id="L787"><span class="lineNum">     787</span>                 :             :         assert((chunkSize &amp; (chunkSize - 1)) == 0);  /* chunkSize must be power of 2 for mask==(chunkSize-1) to work */</span>
<span id="L788"><span class="lineNum">     788</span>                 :<span class="tlaUNC">           0 :         if ((nbChunks &gt; 0) | job-&gt;lastJob /*must output a &quot;last block&quot; flag*/ ) {</span></span>
<span id="L789"><span class="lineNum">     789</span>                 :<span class="tlaUNC">           0 :             size_t const lastBlockSize1 = job-&gt;src.size &amp; (chunkSize-1);</span></span>
<span id="L790"><span class="lineNum">     790</span>                 :<span class="tlaUNC">           0 :             size_t const lastBlockSize = ((lastBlockSize1==0) &amp; (job-&gt;src.size&gt;=chunkSize)) ? chunkSize : lastBlockSize1;</span></span>
<span id="L791"><span class="lineNum">     791</span>                 :<span class="tlaUNC">           0 :             size_t const cSize = (job-&gt;lastJob) ?</span></span>
<span id="L792"><span class="lineNum">     792</span>                 :<span class="tlaUNC">           0 :                  ZSTD_compressEnd_public(cctx, op, oend-op, ip, lastBlockSize) :</span></span>
<span id="L793"><span class="lineNum">     793</span>                 :<span class="tlaUNC">           0 :                  ZSTD_compressContinue_public(cctx, op, oend-op, ip, lastBlockSize);</span></span>
<span id="L794"><span class="lineNum">     794</span>                 :<span class="tlaUNC">           0 :             if (ZSTD_isError(cSize)) JOB_ERROR(cSize);</span></span>
<span id="L795"><span class="lineNum">     795</span>                 :<span class="tlaUNC">           0 :             lastCBlockSize = cSize;</span></span>
<span id="L796"><span class="lineNum">     796</span>                 :<span class="tlaUNC">           0 :     }   }</span></span>
<span id="L797"><span class="lineNum">     797</span>                 :<span class="tlaUNC">           0 :     if (!job-&gt;firstJob) {</span></span>
<span id="L798"><span class="lineNum">     798</span>                 :             :         /* Double check that we don't have an ext-dict, because then our</span>
<span id="L799"><span class="lineNum">     799</span>                 :             :          * repcode invalidation doesn't work.</span>
<span id="L800"><span class="lineNum">     800</span>                 :             :          */</span>
<span id="L801"><span class="lineNum">     801</span>                 :             :         assert(!ZSTD_window_hasExtDict(cctx-&gt;blockState.matchState.window));</span>
<span id="L802"><span class="lineNum">     802</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L803"><span class="lineNum">     803</span>                 :<span class="tlaUNC">           0 :     ZSTD_CCtx_trace(cctx, 0);</span></span>
<span id="L804"><span class="lineNum">     804</span>                 :             : </span>
<span id="L805"><span class="lineNum">     805</span>                 :             : _endJob:</span>
<span id="L806"><span class="lineNum">     806</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_serialState_ensureFinished(job-&gt;serial, job-&gt;jobID, job-&gt;cSize);</span></span>
<span id="L807"><span class="lineNum">     807</span>                 :<span class="tlaUNC">           0 :     if (job-&gt;prefix.size &gt; 0)</span></span>
<span id="L808"><span class="lineNum">     808</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;Finished with prefix: %zx&quot;, (size_t)job-&gt;prefix.start);</span></span>
<span id="L809"><span class="lineNum">     809</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;Finished with source: %zx&quot;, (size_t)job-&gt;src.start);</span></span>
<span id="L810"><span class="lineNum">     810</span>                 :             :     /* release resources */</span>
<span id="L811"><span class="lineNum">     811</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_releaseSeq(job-&gt;seqPool, rawSeqStore);</span></span>
<span id="L812"><span class="lineNum">     812</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_releaseCCtx(job-&gt;cctxPool, cctx);</span></span>
<span id="L813"><span class="lineNum">     813</span>                 :             :     /* report */</span>
<span id="L814"><span class="lineNum">     814</span>                 :<span class="tlaUNC">           0 :     ZSTD_PTHREAD_MUTEX_LOCK(&amp;job-&gt;job_mutex);</span></span>
<span id="L815"><span class="lineNum">     815</span>                 :<span class="tlaUNC">           0 :     if (ZSTD_isError(job-&gt;cSize)) assert(lastCBlockSize == 0);</span></span>
<span id="L816"><span class="lineNum">     816</span>                 :<span class="tlaUNC">           0 :     job-&gt;cSize += lastCBlockSize;</span></span>
<span id="L817"><span class="lineNum">     817</span>                 :<span class="tlaUNC">           0 :     job-&gt;consumed = job-&gt;src.size;  /* when job-&gt;consumed == job-&gt;src.size , compression job is presumed completed */</span></span>
<span id="L818"><span class="lineNum">     818</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_cond_signal(&amp;job-&gt;job_cond);</span></span>
<span id="L819"><span class="lineNum">     819</span>                 :<span class="tlaUNC">           0 :     ZSTD_pthread_mutex_unlock(&amp;job-&gt;job_mutex);</span></span>
<span id="L820"><span class="lineNum">     820</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L821"><span class="lineNum">     821</span>                 :             : </span>
<span id="L822"><span class="lineNum">     822</span>                 :             : </span>
<span id="L823"><span class="lineNum">     823</span>                 :             : /* ------------------------------------------ */</span>
<span id="L824"><span class="lineNum">     824</span>                 :             : /* =====   Multi-threaded compression   ===== */</span>
<span id="L825"><span class="lineNum">     825</span>                 :             : /* ------------------------------------------ */</span>
<span id="L826"><span class="lineNum">     826</span>                 :             : </span>
<span id="L827"><span class="lineNum">     827</span>                 :             : typedef struct {</span>
<span id="L828"><span class="lineNum">     828</span>                 :             :     Range prefix;         /* read-only non-owned prefix buffer */</span>
<span id="L829"><span class="lineNum">     829</span>                 :             :     Buffer buffer;</span>
<span id="L830"><span class="lineNum">     830</span>                 :             :     size_t filled;</span>
<span id="L831"><span class="lineNum">     831</span>                 :             : } InBuff_t;</span>
<span id="L832"><span class="lineNum">     832</span>                 :             : </span>
<span id="L833"><span class="lineNum">     833</span>                 :             : typedef struct {</span>
<span id="L834"><span class="lineNum">     834</span>                 :             :   BYTE* buffer;     /* The round input buffer. All jobs get references</span>
<span id="L835"><span class="lineNum">     835</span>                 :             :                      * to pieces of the buffer. ZSTDMT_tryGetInputRange()</span>
<span id="L836"><span class="lineNum">     836</span>                 :             :                      * handles handing out job input buffers, and makes</span>
<span id="L837"><span class="lineNum">     837</span>                 :             :                      * sure it doesn't overlap with any pieces still in use.</span>
<span id="L838"><span class="lineNum">     838</span>                 :             :                      */</span>
<span id="L839"><span class="lineNum">     839</span>                 :             :   size_t capacity;  /* The capacity of buffer. */</span>
<span id="L840"><span class="lineNum">     840</span>                 :             :   size_t pos;       /* The position of the current inBuff in the round</span>
<span id="L841"><span class="lineNum">     841</span>                 :             :                      * buffer. Updated past the end if the inBuff once</span>
<span id="L842"><span class="lineNum">     842</span>                 :             :                      * the inBuff is sent to the worker thread.</span>
<span id="L843"><span class="lineNum">     843</span>                 :             :                      * pos &lt;= capacity.</span>
<span id="L844"><span class="lineNum">     844</span>                 :             :                      */</span>
<span id="L845"><span class="lineNum">     845</span>                 :             : } RoundBuff_t;</span>
<span id="L846"><span class="lineNum">     846</span>                 :             : </span>
<span id="L847"><span class="lineNum">     847</span>                 :             : static const RoundBuff_t kNullRoundBuff = {NULL, 0, 0};</span>
<span id="L848"><span class="lineNum">     848</span>                 :             : </span>
<span id="L849"><span class="lineNum">     849</span>                 :             : #define RSYNC_LENGTH 32</span>
<span id="L850"><span class="lineNum">     850</span>                 :             : /* Don't create chunks smaller than the zstd block size.</span>
<span id="L851"><span class="lineNum">     851</span>                 :             :  * This stops us from regressing compression ratio too much,</span>
<span id="L852"><span class="lineNum">     852</span>                 :             :  * and ensures our output fits in ZSTD_compressBound().</span>
<span id="L853"><span class="lineNum">     853</span>                 :             :  *</span>
<span id="L854"><span class="lineNum">     854</span>                 :             :  * If this is shrunk &lt; ZSTD_BLOCKSIZELOG_MIN then</span>
<span id="L855"><span class="lineNum">     855</span>                 :             :  * ZSTD_COMPRESSBOUND() will need to be updated.</span>
<span id="L856"><span class="lineNum">     856</span>                 :             :  */</span>
<span id="L857"><span class="lineNum">     857</span>                 :             : #define RSYNC_MIN_BLOCK_LOG ZSTD_BLOCKSIZELOG_MAX</span>
<span id="L858"><span class="lineNum">     858</span>                 :             : #define RSYNC_MIN_BLOCK_SIZE (1&lt;&lt;RSYNC_MIN_BLOCK_LOG)</span>
<span id="L859"><span class="lineNum">     859</span>                 :             : </span>
<span id="L860"><span class="lineNum">     860</span>                 :             : typedef struct {</span>
<span id="L861"><span class="lineNum">     861</span>                 :             :   U64 hash;</span>
<span id="L862"><span class="lineNum">     862</span>                 :             :   U64 hitMask;</span>
<span id="L863"><span class="lineNum">     863</span>                 :             :   U64 primePower;</span>
<span id="L864"><span class="lineNum">     864</span>                 :             : } RSyncState_t;</span>
<span id="L865"><span class="lineNum">     865</span>                 :             : </span>
<span id="L866"><span class="lineNum">     866</span>                 :             : struct ZSTDMT_CCtx_s {</span>
<span id="L867"><span class="lineNum">     867</span>                 :             :     POOL_ctx* factory;</span>
<span id="L868"><span class="lineNum">     868</span>                 :             :     ZSTDMT_jobDescription* jobs;</span>
<span id="L869"><span class="lineNum">     869</span>                 :             :     ZSTDMT_bufferPool* bufPool;</span>
<span id="L870"><span class="lineNum">     870</span>                 :             :     ZSTDMT_CCtxPool* cctxPool;</span>
<span id="L871"><span class="lineNum">     871</span>                 :             :     ZSTDMT_seqPool* seqPool;</span>
<span id="L872"><span class="lineNum">     872</span>                 :             :     ZSTD_CCtx_params params;</span>
<span id="L873"><span class="lineNum">     873</span>                 :             :     size_t targetSectionSize;</span>
<span id="L874"><span class="lineNum">     874</span>                 :             :     size_t targetPrefixSize;</span>
<span id="L875"><span class="lineNum">     875</span>                 :             :     int jobReady;        /* 1 =&gt; one job is already prepared, but pool has shortage of workers. Don't create a new job. */</span>
<span id="L876"><span class="lineNum">     876</span>                 :             :     InBuff_t inBuff;</span>
<span id="L877"><span class="lineNum">     877</span>                 :             :     RoundBuff_t roundBuff;</span>
<span id="L878"><span class="lineNum">     878</span>                 :             :     SerialState serial;</span>
<span id="L879"><span class="lineNum">     879</span>                 :             :     RSyncState_t rsync;</span>
<span id="L880"><span class="lineNum">     880</span>                 :             :     unsigned jobIDMask;</span>
<span id="L881"><span class="lineNum">     881</span>                 :             :     unsigned doneJobID;</span>
<span id="L882"><span class="lineNum">     882</span>                 :             :     unsigned nextJobID;</span>
<span id="L883"><span class="lineNum">     883</span>                 :             :     unsigned frameEnded;</span>
<span id="L884"><span class="lineNum">     884</span>                 :             :     unsigned allJobsCompleted;</span>
<span id="L885"><span class="lineNum">     885</span>                 :             :     unsigned long long frameContentSize;</span>
<span id="L886"><span class="lineNum">     886</span>                 :             :     unsigned long long consumed;</span>
<span id="L887"><span class="lineNum">     887</span>                 :             :     unsigned long long produced;</span>
<span id="L888"><span class="lineNum">     888</span>                 :             :     ZSTD_customMem cMem;</span>
<span id="L889"><span class="lineNum">     889</span>                 :             :     ZSTD_CDict* cdictLocal;</span>
<span id="L890"><span class="lineNum">     890</span>                 :             :     const ZSTD_CDict* cdict;</span>
<span id="L891"><span class="lineNum">     891</span>                 :             :     unsigned providedFactory: 1;</span>
<span id="L892"><span class="lineNum">     892</span>                 :             : };</span>
<span id="L893"><span class="lineNum">     893</span>                 :             : </span>
<span id="L894"><span class="lineNum">     894</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_freeJobsTable(ZSTDMT_jobDescription* jobTable, U32 nbJobs, ZSTD_customMem cMem)</span></span>
<span id="L895"><span class="lineNum">     895</span>                 :             : {</span>
<span id="L896"><span class="lineNum">     896</span>                 :             :     U32 jobNb;</span>
<span id="L897"><span class="lineNum">     897</span>                 :<span class="tlaUNC">           0 :     if (jobTable == NULL) return;</span></span>
<span id="L898"><span class="lineNum">     898</span>                 :<span class="tlaUNC">           0 :     for (jobNb=0; jobNb&lt;nbJobs; jobNb++) {</span></span>
<span id="L899"><span class="lineNum">     899</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_mutex_destroy(&amp;jobTable[jobNb].job_mutex);</span></span>
<span id="L900"><span class="lineNum">     900</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_cond_destroy(&amp;jobTable[jobNb].job_cond);</span></span>
<span id="L901"><span class="lineNum">     901</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L902"><span class="lineNum">     902</span>                 :<span class="tlaUNC">           0 :     ZSTD_customFree(jobTable, cMem);</span></span>
<span id="L903"><span class="lineNum">     903</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L904"><span class="lineNum">     904</span>                 :             : </span>
<span id="L905"><span class="lineNum">     905</span>                 :             : /* ZSTDMT_allocJobsTable()</span>
<span id="L906"><span class="lineNum">     906</span>                 :             :  * allocate and init a job table.</span>
<span id="L907"><span class="lineNum">     907</span>                 :             :  * update *nbJobsPtr to next power of 2 value, as size of table */</span>
<span id="L908"><span class="lineNum">     908</span>                 :<span class="tlaUNC">           0 : static ZSTDMT_jobDescription* ZSTDMT_createJobsTable(U32* nbJobsPtr, ZSTD_customMem cMem)</span></span>
<span id="L909"><span class="lineNum">     909</span>                 :             : {</span>
<span id="L910"><span class="lineNum">     910</span>                 :<span class="tlaUNC">           0 :     U32 const nbJobsLog2 = ZSTD_highbit32(*nbJobsPtr) + 1;</span></span>
<span id="L911"><span class="lineNum">     911</span>                 :<span class="tlaUNC">           0 :     U32 const nbJobs = 1 &lt;&lt; nbJobsLog2;</span></span>
<span id="L912"><span class="lineNum">     912</span>                 :             :     U32 jobNb;</span>
<span id="L913"><span class="lineNum">     913</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_jobDescription* const jobTable = (ZSTDMT_jobDescription*)</span></span>
<span id="L914"><span class="lineNum">     914</span>                 :<span class="tlaUNC">           0 :                 ZSTD_customCalloc(nbJobs * sizeof(ZSTDMT_jobDescription), cMem);</span></span>
<span id="L915"><span class="lineNum">     915</span>                 :<span class="tlaUNC">           0 :     int initError = 0;</span></span>
<span id="L916"><span class="lineNum">     916</span>                 :<span class="tlaUNC">           0 :     if (jobTable==NULL) return NULL;</span></span>
<span id="L917"><span class="lineNum">     917</span>                 :<span class="tlaUNC">           0 :     *nbJobsPtr = nbJobs;</span></span>
<span id="L918"><span class="lineNum">     918</span>                 :<span class="tlaUNC">           0 :     for (jobNb=0; jobNb&lt;nbJobs; jobNb++) {</span></span>
<span id="L919"><span class="lineNum">     919</span>                 :<span class="tlaUNC">           0 :         initError |= ZSTD_pthread_mutex_init(&amp;jobTable[jobNb].job_mutex, NULL);</span></span>
<span id="L920"><span class="lineNum">     920</span>                 :<span class="tlaUNC">           0 :         initError |= ZSTD_pthread_cond_init(&amp;jobTable[jobNb].job_cond, NULL);</span></span>
<span id="L921"><span class="lineNum">     921</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L922"><span class="lineNum">     922</span>                 :<span class="tlaUNC">           0 :     if (initError != 0) {</span></span>
<span id="L923"><span class="lineNum">     923</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_freeJobsTable(jobTable, nbJobs, cMem);</span></span>
<span id="L924"><span class="lineNum">     924</span>                 :<span class="tlaUNC">           0 :         return NULL;</span></span>
<span id="L925"><span class="lineNum">     925</span>                 :             :     }</span>
<span id="L926"><span class="lineNum">     926</span>                 :<span class="tlaUNC">           0 :     return jobTable;</span></span>
<span id="L927"><span class="lineNum">     927</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L928"><span class="lineNum">     928</span>                 :             : </span>
<span id="L929"><span class="lineNum">     929</span>                 :<span class="tlaUNC">           0 : static size_t ZSTDMT_expandJobsTable (ZSTDMT_CCtx* mtctx, U32 nbWorkers) {</span></span>
<span id="L930"><span class="lineNum">     930</span>                 :<span class="tlaUNC">           0 :     U32 nbJobs = nbWorkers + 2;</span></span>
<span id="L931"><span class="lineNum">     931</span>                 :<span class="tlaUNC">           0 :     if (nbJobs &gt; mtctx-&gt;jobIDMask+1) {  /* need more job capacity */</span></span>
<span id="L932"><span class="lineNum">     932</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_freeJobsTable(mtctx-&gt;jobs, mtctx-&gt;jobIDMask+1, mtctx-&gt;cMem);</span></span>
<span id="L933"><span class="lineNum">     933</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobIDMask = 0;</span></span>
<span id="L934"><span class="lineNum">     934</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs = ZSTDMT_createJobsTable(&amp;nbJobs, mtctx-&gt;cMem);</span></span>
<span id="L935"><span class="lineNum">     935</span>                 :<span class="tlaUNC">           0 :         if (mtctx-&gt;jobs==NULL) return ERROR(memory_allocation);</span></span>
<span id="L936"><span class="lineNum">     936</span>                 :             :         assert((nbJobs != 0) &amp;&amp; ((nbJobs &amp; (nbJobs - 1)) == 0));  /* ensure nbJobs is a power of 2 */</span>
<span id="L937"><span class="lineNum">     937</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobIDMask = nbJobs - 1;</span></span>
<span id="L938"><span class="lineNum">     938</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L939"><span class="lineNum">     939</span>                 :<span class="tlaUNC">           0 :     return 0;</span></span>
<span id="L940"><span class="lineNum">     940</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L941"><span class="lineNum">     941</span>                 :             : </span>
<span id="L942"><span class="lineNum">     942</span>                 :             : </span>
<span id="L943"><span class="lineNum">     943</span>                 :             : /* ZSTDMT_CCtxParam_setNbWorkers():</span>
<span id="L944"><span class="lineNum">     944</span>                 :             :  * Internal use only */</span>
<span id="L945"><span class="lineNum">     945</span>                 :<span class="tlaUNC">           0 : static size_t ZSTDMT_CCtxParam_setNbWorkers(ZSTD_CCtx_params* params, unsigned nbWorkers)</span></span>
<span id="L946"><span class="lineNum">     946</span>                 :             : {</span>
<span id="L947"><span class="lineNum">     947</span>                 :<span class="tlaUNC">           0 :     return ZSTD_CCtxParams_setParameter(params, ZSTD_c_nbWorkers, (int)nbWorkers);</span></span>
<span id="L948"><span class="lineNum">     948</span>                 :             : }</span>
<span id="L949"><span class="lineNum">     949</span>                 :             : </span>
<span id="L950"><span class="lineNum">     950</span>                 :             : MEM_STATIC ZSTDMT_CCtx* ZSTDMT_createCCtx_advanced_internal(unsigned nbWorkers, ZSTD_customMem cMem, ZSTD_threadPool* pool)</span>
<span id="L951"><span class="lineNum">     951</span>                 :             : {</span>
<span id="L952"><span class="lineNum">     952</span>                 :             :     ZSTDMT_CCtx* mtctx;</span>
<span id="L953"><span class="lineNum">     953</span>                 :             :     U32 nbJobs = nbWorkers + 2;</span>
<span id="L954"><span class="lineNum">     954</span>                 :             :     int initError;</span>
<span id="L955"><span class="lineNum">     955</span>                 :             :     DEBUGLOG(3, &quot;ZSTDMT_createCCtx_advanced (nbWorkers = %u)&quot;, nbWorkers);</span>
<span id="L956"><span class="lineNum">     956</span>                 :             : </span>
<span id="L957"><span class="lineNum">     957</span>                 :             :     if (nbWorkers &lt; 1) return NULL;</span>
<span id="L958"><span class="lineNum">     958</span>                 :             :     nbWorkers = MIN(nbWorkers , ZSTDMT_NBWORKERS_MAX);</span>
<span id="L959"><span class="lineNum">     959</span>                 :             :     if ((cMem.customAlloc!=NULL) ^ (cMem.customFree!=NULL))</span>
<span id="L960"><span class="lineNum">     960</span>                 :             :         /* invalid custom allocator */</span>
<span id="L961"><span class="lineNum">     961</span>                 :             :         return NULL;</span>
<span id="L962"><span class="lineNum">     962</span>                 :             : </span>
<span id="L963"><span class="lineNum">     963</span>                 :             :     mtctx = (ZSTDMT_CCtx*) ZSTD_customCalloc(sizeof(ZSTDMT_CCtx), cMem);</span>
<span id="L964"><span class="lineNum">     964</span>                 :             :     if (!mtctx) return NULL;</span>
<span id="L965"><span class="lineNum">     965</span>                 :             :     ZSTDMT_CCtxParam_setNbWorkers(&amp;mtctx-&gt;params, nbWorkers);</span>
<span id="L966"><span class="lineNum">     966</span>                 :             :     mtctx-&gt;cMem = cMem;</span>
<span id="L967"><span class="lineNum">     967</span>                 :             :     mtctx-&gt;allJobsCompleted = 1;</span>
<span id="L968"><span class="lineNum">     968</span>                 :             :     if (pool != NULL) {</span>
<span id="L969"><span class="lineNum">     969</span>                 :             :       mtctx-&gt;factory = pool;</span>
<span id="L970"><span class="lineNum">     970</span>                 :             :       mtctx-&gt;providedFactory = 1;</span>
<span id="L971"><span class="lineNum">     971</span>                 :             :     }</span>
<span id="L972"><span class="lineNum">     972</span>                 :             :     else {</span>
<span id="L973"><span class="lineNum">     973</span>                 :             :       mtctx-&gt;factory = POOL_create_advanced(nbWorkers, 0, cMem);</span>
<span id="L974"><span class="lineNum">     974</span>                 :             :       mtctx-&gt;providedFactory = 0;</span>
<span id="L975"><span class="lineNum">     975</span>                 :             :     }</span>
<span id="L976"><span class="lineNum">     976</span>                 :             :     mtctx-&gt;jobs = ZSTDMT_createJobsTable(&amp;nbJobs, cMem);</span>
<span id="L977"><span class="lineNum">     977</span>                 :             :     assert(nbJobs &gt; 0); assert((nbJobs &amp; (nbJobs - 1)) == 0);  /* ensure nbJobs is a power of 2 */</span>
<span id="L978"><span class="lineNum">     978</span>                 :             :     mtctx-&gt;jobIDMask = nbJobs - 1;</span>
<span id="L979"><span class="lineNum">     979</span>                 :             :     mtctx-&gt;bufPool = ZSTDMT_createBufferPool(BUF_POOL_MAX_NB_BUFFERS(nbWorkers), cMem);</span>
<span id="L980"><span class="lineNum">     980</span>                 :             :     mtctx-&gt;cctxPool = ZSTDMT_createCCtxPool(nbWorkers, cMem);</span>
<span id="L981"><span class="lineNum">     981</span>                 :             :     mtctx-&gt;seqPool = ZSTDMT_createSeqPool(nbWorkers, cMem);</span>
<span id="L982"><span class="lineNum">     982</span>                 :             :     initError = ZSTDMT_serialState_init(&amp;mtctx-&gt;serial);</span>
<span id="L983"><span class="lineNum">     983</span>                 :             :     mtctx-&gt;roundBuff = kNullRoundBuff;</span>
<span id="L984"><span class="lineNum">     984</span>                 :             :     if (!mtctx-&gt;factory | !mtctx-&gt;jobs | !mtctx-&gt;bufPool | !mtctx-&gt;cctxPool | !mtctx-&gt;seqPool | initError) {</span>
<span id="L985"><span class="lineNum">     985</span>                 :             :         ZSTDMT_freeCCtx(mtctx);</span>
<span id="L986"><span class="lineNum">     986</span>                 :             :         return NULL;</span>
<span id="L987"><span class="lineNum">     987</span>                 :             :     }</span>
<span id="L988"><span class="lineNum">     988</span>                 :             :     DEBUGLOG(3, &quot;mt_cctx created, for %u threads&quot;, nbWorkers);</span>
<span id="L989"><span class="lineNum">     989</span>                 :             :     return mtctx;</span>
<span id="L990"><span class="lineNum">     990</span>                 :             : }</span>
<span id="L991"><span class="lineNum">     991</span>                 :             : </span>
<span id="L992"><span class="lineNum">     992</span>                 :<span class="tlaUNC">           0 : ZSTDMT_CCtx* ZSTDMT_createCCtx_advanced(unsigned nbWorkers, ZSTD_customMem cMem, ZSTD_threadPool* pool)</span></span>
<span id="L993"><span class="lineNum">     993</span>                 :             : {</span>
<span id="L994"><span class="lineNum">     994</span>                 :             : #ifdef ZSTD_MULTITHREAD</span>
<span id="L995"><span class="lineNum">     995</span>                 :             :     return ZSTDMT_createCCtx_advanced_internal(nbWorkers, cMem, pool);</span>
<span id="L996"><span class="lineNum">     996</span>                 :             : #else</span>
<span id="L997"><span class="lineNum">     997</span>                 :<span class="tlaUNC">           0 :     (void)nbWorkers;</span></span>
<span id="L998"><span class="lineNum">     998</span>                 :             :     (void)cMem;</span>
<span id="L999"><span class="lineNum">     999</span>                 :<span class="tlaUNC">           0 :     (void)pool;</span></span>
<span id="L1000"><span class="lineNum">    1000</span>                 :<span class="tlaUNC">           0 :     return NULL;</span></span>
<span id="L1001"><span class="lineNum">    1001</span>                 :             : #endif</span>
<span id="L1002"><span class="lineNum">    1002</span>                 :             : }</span>
<span id="L1003"><span class="lineNum">    1003</span>                 :             : </span>
<span id="L1004"><span class="lineNum">    1004</span>                 :             : </span>
<span id="L1005"><span class="lineNum">    1005</span>                 :             : /* ZSTDMT_releaseAllJobResources() :</span>
<span id="L1006"><span class="lineNum">    1006</span>                 :             :  * note : ensure all workers are killed first ! */</span>
<span id="L1007"><span class="lineNum">    1007</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_releaseAllJobResources(ZSTDMT_CCtx* mtctx)</span></span>
<span id="L1008"><span class="lineNum">    1008</span>                 :             : {</span>
<span id="L1009"><span class="lineNum">    1009</span>                 :             :     unsigned jobID;</span>
<span id="L1010"><span class="lineNum">    1010</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(3, &quot;ZSTDMT_releaseAllJobResources&quot;);</span></span>
<span id="L1011"><span class="lineNum">    1011</span>                 :<span class="tlaUNC">           0 :     for (jobID=0; jobID &lt;= mtctx-&gt;jobIDMask; jobID++) {</span></span>
<span id="L1012"><span class="lineNum">    1012</span>                 :             :         /* Copy the mutex/cond out */</span>
<span id="L1013"><span class="lineNum">    1013</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_mutex_t const mutex = mtctx-&gt;jobs[jobID].job_mutex;</span></span>
<span id="L1014"><span class="lineNum">    1014</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_cond_t const cond = mtctx-&gt;jobs[jobID].job_cond;</span></span>
<span id="L1015"><span class="lineNum">    1015</span>                 :             : </span>
<span id="L1016"><span class="lineNum">    1016</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(4, &quot;job%02u: release dst address %08X&quot;, jobID, (U32)(size_t)mtctx-&gt;jobs[jobID].dstBuff.start);</span></span>
<span id="L1017"><span class="lineNum">    1017</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_releaseBuffer(mtctx-&gt;bufPool, mtctx-&gt;jobs[jobID].dstBuff);</span></span>
<span id="L1018"><span class="lineNum">    1018</span>                 :             : </span>
<span id="L1019"><span class="lineNum">    1019</span>                 :             :         /* Clear the job description, but keep the mutex/cond */</span>
<span id="L1020"><span class="lineNum">    1020</span>                 :<span class="tlaUNC">           0 :         ZSTD_memset(&amp;mtctx-&gt;jobs[jobID], 0, sizeof(mtctx-&gt;jobs[jobID]));</span></span>
<span id="L1021"><span class="lineNum">    1021</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].job_mutex = mutex;</span></span>
<span id="L1022"><span class="lineNum">    1022</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].job_cond = cond;</span></span>
<span id="L1023"><span class="lineNum">    1023</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1024"><span class="lineNum">    1024</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;inBuff.buffer = g_nullBuffer;</span></span>
<span id="L1025"><span class="lineNum">    1025</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;inBuff.filled = 0;</span></span>
<span id="L1026"><span class="lineNum">    1026</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;allJobsCompleted = 1;</span></span>
<span id="L1027"><span class="lineNum">    1027</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1028"><span class="lineNum">    1028</span>                 :             : </span>
<span id="L1029"><span class="lineNum">    1029</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_waitForAllJobsCompleted(ZSTDMT_CCtx* mtctx)</span></span>
<span id="L1030"><span class="lineNum">    1030</span>                 :             : {</span>
<span id="L1031"><span class="lineNum">    1031</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(4, &quot;ZSTDMT_waitForAllJobsCompleted&quot;);</span></span>
<span id="L1032"><span class="lineNum">    1032</span>                 :<span class="tlaUNC">           0 :     while (mtctx-&gt;doneJobID &lt; mtctx-&gt;nextJobID) {</span></span>
<span id="L1033"><span class="lineNum">    1033</span>                 :<span class="tlaUNC">           0 :         unsigned const jobID = mtctx-&gt;doneJobID &amp; mtctx-&gt;jobIDMask;</span></span>
<span id="L1034"><span class="lineNum">    1034</span>                 :<span class="tlaUNC">           0 :         ZSTD_PTHREAD_MUTEX_LOCK(&amp;mtctx-&gt;jobs[jobID].job_mutex);</span></span>
<span id="L1035"><span class="lineNum">    1035</span>                 :<span class="tlaUNC">           0 :         while (mtctx-&gt;jobs[jobID].consumed &lt; mtctx-&gt;jobs[jobID].src.size) {</span></span>
<span id="L1036"><span class="lineNum">    1036</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(4, &quot;waiting for jobCompleted signal from job %u&quot;, mtctx-&gt;doneJobID);   /* we want to block when waiting for data to flush */</span></span>
<span id="L1037"><span class="lineNum">    1037</span>                 :<span class="tlaUNC">           0 :             ZSTD_pthread_cond_wait(&amp;mtctx-&gt;jobs[jobID].job_cond, &amp;mtctx-&gt;jobs[jobID].job_mutex);</span></span>
<span id="L1038"><span class="lineNum">    1038</span>                 :             :         }</span>
<span id="L1039"><span class="lineNum">    1039</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_mutex_unlock(&amp;mtctx-&gt;jobs[jobID].job_mutex);</span></span>
<span id="L1040"><span class="lineNum">    1040</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;doneJobID++;</span></span>
<span id="L1041"><span class="lineNum">    1041</span>                 :             :     }</span>
<span id="L1042"><span class="lineNum">    1042</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1043"><span class="lineNum">    1043</span>                 :             : </span>
<span id="L1044"><span class="lineNum">    1044</span>                 :<span class="tlaUNC">           0 : size_t ZSTDMT_freeCCtx(ZSTDMT_CCtx* mtctx)</span></span>
<span id="L1045"><span class="lineNum">    1045</span>                 :             : {</span>
<span id="L1046"><span class="lineNum">    1046</span>                 :<span class="tlaUNC">           0 :     if (mtctx==NULL) return 0;   /* compatible with free on NULL */</span></span>
<span id="L1047"><span class="lineNum">    1047</span>                 :<span class="tlaUNC">           0 :     if (!mtctx-&gt;providedFactory)</span></span>
<span id="L1048"><span class="lineNum">    1048</span>                 :<span class="tlaUNC">           0 :         POOL_free(mtctx-&gt;factory);   /* stop and free worker threads */</span></span>
<span id="L1049"><span class="lineNum">    1049</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_releaseAllJobResources(mtctx);  /* release job resources into pools first */</span></span>
<span id="L1050"><span class="lineNum">    1050</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_freeJobsTable(mtctx-&gt;jobs, mtctx-&gt;jobIDMask+1, mtctx-&gt;cMem);</span></span>
<span id="L1051"><span class="lineNum">    1051</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_freeBufferPool(mtctx-&gt;bufPool);</span></span>
<span id="L1052"><span class="lineNum">    1052</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_freeCCtxPool(mtctx-&gt;cctxPool);</span></span>
<span id="L1053"><span class="lineNum">    1053</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_freeSeqPool(mtctx-&gt;seqPool);</span></span>
<span id="L1054"><span class="lineNum">    1054</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_serialState_free(&amp;mtctx-&gt;serial);</span></span>
<span id="L1055"><span class="lineNum">    1055</span>                 :<span class="tlaUNC">           0 :     ZSTD_freeCDict(mtctx-&gt;cdictLocal);</span></span>
<span id="L1056"><span class="lineNum">    1056</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;roundBuff.buffer)</span></span>
<span id="L1057"><span class="lineNum">    1057</span>                 :<span class="tlaUNC">           0 :         ZSTD_customFree(mtctx-&gt;roundBuff.buffer, mtctx-&gt;cMem);</span></span>
<span id="L1058"><span class="lineNum">    1058</span>                 :<span class="tlaUNC">           0 :     ZSTD_customFree(mtctx, mtctx-&gt;cMem);</span></span>
<span id="L1059"><span class="lineNum">    1059</span>                 :<span class="tlaUNC">           0 :     return 0;</span></span>
<span id="L1060"><span class="lineNum">    1060</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1061"><span class="lineNum">    1061</span>                 :             : </span>
<span id="L1062"><span class="lineNum">    1062</span>                 :<span class="tlaUNC">           0 : size_t ZSTDMT_sizeof_CCtx(ZSTDMT_CCtx* mtctx)</span></span>
<span id="L1063"><span class="lineNum">    1063</span>                 :             : {</span>
<span id="L1064"><span class="lineNum">    1064</span>                 :<span class="tlaUNC">           0 :     if (mtctx == NULL) return 0;   /* supports sizeof NULL */</span></span>
<span id="L1065"><span class="lineNum">    1065</span>                 :<span class="tlaUNC">           0 :     return sizeof(*mtctx)</span></span>
<span id="L1066"><span class="lineNum">    1066</span>                 :<span class="tlaUNC">           0 :             + POOL_sizeof(mtctx-&gt;factory)</span></span>
<span id="L1067"><span class="lineNum">    1067</span>                 :<span class="tlaUNC">           0 :             + ZSTDMT_sizeof_bufferPool(mtctx-&gt;bufPool)</span></span>
<span id="L1068"><span class="lineNum">    1068</span>                 :<span class="tlaUNC">           0 :             + (mtctx-&gt;jobIDMask+1) * sizeof(ZSTDMT_jobDescription)</span></span>
<span id="L1069"><span class="lineNum">    1069</span>                 :<span class="tlaUNC">           0 :             + ZSTDMT_sizeof_CCtxPool(mtctx-&gt;cctxPool)</span></span>
<span id="L1070"><span class="lineNum">    1070</span>                 :<span class="tlaUNC">           0 :             + ZSTDMT_sizeof_seqPool(mtctx-&gt;seqPool)</span></span>
<span id="L1071"><span class="lineNum">    1071</span>                 :<span class="tlaUNC">           0 :             + ZSTD_sizeof_CDict(mtctx-&gt;cdictLocal)</span></span>
<span id="L1072"><span class="lineNum">    1072</span>                 :<span class="tlaUNC">           0 :             + mtctx-&gt;roundBuff.capacity;</span></span>
<span id="L1073"><span class="lineNum">    1073</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1074"><span class="lineNum">    1074</span>                 :             : </span>
<span id="L1075"><span class="lineNum">    1075</span>                 :             : </span>
<span id="L1076"><span class="lineNum">    1076</span>                 :             : /* ZSTDMT_resize() :</span>
<span id="L1077"><span class="lineNum">    1077</span>                 :             :  * @return : error code if fails, 0 on success */</span>
<span id="L1078"><span class="lineNum">    1078</span>                 :<span class="tlaUNC">           0 : static size_t ZSTDMT_resize(ZSTDMT_CCtx* mtctx, unsigned nbWorkers)</span></span>
<span id="L1079"><span class="lineNum">    1079</span>                 :             : {</span>
<span id="L1080"><span class="lineNum">    1080</span>                 :<span class="tlaUNC">           0 :     if (POOL_resize(mtctx-&gt;factory, nbWorkers)) return ERROR(memory_allocation);</span></span>
<span id="L1081"><span class="lineNum">    1081</span>                 :<span class="tlaUNC">           0 :     FORWARD_IF_ERROR( ZSTDMT_expandJobsTable(mtctx, nbWorkers) , &quot;&quot;);</span></span>
<span id="L1082"><span class="lineNum">    1082</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;bufPool = ZSTDMT_expandBufferPool(mtctx-&gt;bufPool, BUF_POOL_MAX_NB_BUFFERS(nbWorkers));</span></span>
<span id="L1083"><span class="lineNum">    1083</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;bufPool == NULL) return ERROR(memory_allocation);</span></span>
<span id="L1084"><span class="lineNum">    1084</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;cctxPool = ZSTDMT_expandCCtxPool(mtctx-&gt;cctxPool, nbWorkers);</span></span>
<span id="L1085"><span class="lineNum">    1085</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;cctxPool == NULL) return ERROR(memory_allocation);</span></span>
<span id="L1086"><span class="lineNum">    1086</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;seqPool = ZSTDMT_expandSeqPool(mtctx-&gt;seqPool, nbWorkers);</span></span>
<span id="L1087"><span class="lineNum">    1087</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;seqPool == NULL) return ERROR(memory_allocation);</span></span>
<span id="L1088"><span class="lineNum">    1088</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_CCtxParam_setNbWorkers(&amp;mtctx-&gt;params, nbWorkers);</span></span>
<span id="L1089"><span class="lineNum">    1089</span>                 :<span class="tlaUNC">           0 :     return 0;</span></span>
<span id="L1090"><span class="lineNum">    1090</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1091"><span class="lineNum">    1091</span>                 :             : </span>
<span id="L1092"><span class="lineNum">    1092</span>                 :             : </span>
<span id="L1093"><span class="lineNum">    1093</span>                 :             : /*! ZSTDMT_updateCParams_whileCompressing() :</span>
<span id="L1094"><span class="lineNum">    1094</span>                 :             :  *  Updates a selected set of compression parameters, remaining compatible with currently active frame.</span>
<span id="L1095"><span class="lineNum">    1095</span>                 :             :  *  New parameters will be applied to next compression job. */</span>
<span id="L1096"><span class="lineNum">    1096</span>                 :<span class="tlaUNC">           0 : void ZSTDMT_updateCParams_whileCompressing(ZSTDMT_CCtx* mtctx, const ZSTD_CCtx_params* cctxParams)</span></span>
<span id="L1097"><span class="lineNum">    1097</span>                 :             : {</span>
<span id="L1098"><span class="lineNum">    1098</span>                 :<span class="tlaUNC">           0 :     U32 const saved_wlog = mtctx-&gt;params.cParams.windowLog;   /* Do not modify windowLog while compressing */</span></span>
<span id="L1099"><span class="lineNum">    1099</span>                 :<span class="tlaUNC">           0 :     int const compressionLevel = cctxParams-&gt;compressionLevel;</span></span>
<span id="L1100"><span class="lineNum">    1100</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_updateCParams_whileCompressing (level:%i)&quot;,</span></span>
<span id="L1101"><span class="lineNum">    1101</span>                 :             :                 compressionLevel);</span>
<span id="L1102"><span class="lineNum">    1102</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;params.compressionLevel = compressionLevel;</span></span>
<span id="L1103"><span class="lineNum">    1103</span>                 :<span class="tlaUNC">           0 :     {   ZSTD_compressionParameters cParams = ZSTD_getCParamsFromCCtxParams(cctxParams, ZSTD_CONTENTSIZE_UNKNOWN, 0, ZSTD_cpm_noAttachDict);</span></span>
<span id="L1104"><span class="lineNum">    1104</span>                 :<span class="tlaUNC">           0 :         cParams.windowLog = saved_wlog;</span></span>
<span id="L1105"><span class="lineNum">    1105</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;params.cParams = cParams;</span></span>
<span id="L1106"><span class="lineNum">    1106</span>                 :             :     }</span>
<span id="L1107"><span class="lineNum">    1107</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1108"><span class="lineNum">    1108</span>                 :             : </span>
<span id="L1109"><span class="lineNum">    1109</span>                 :             : /* ZSTDMT_getFrameProgression():</span>
<span id="L1110"><span class="lineNum">    1110</span>                 :             :  * tells how much data has been consumed (input) and produced (output) for current frame.</span>
<span id="L1111"><span class="lineNum">    1111</span>                 :             :  * able to count progression inside worker threads.</span>
<span id="L1112"><span class="lineNum">    1112</span>                 :             :  * Note : mutex will be acquired during statistics collection inside workers. */</span>
<span id="L1113"><span class="lineNum">    1113</span>                 :<span class="tlaUNC">           0 : ZSTD_frameProgression ZSTDMT_getFrameProgression(ZSTDMT_CCtx* mtctx)</span></span>
<span id="L1114"><span class="lineNum">    1114</span>                 :             : {</span>
<span id="L1115"><span class="lineNum">    1115</span>                 :             :     ZSTD_frameProgression fps;</span>
<span id="L1116"><span class="lineNum">    1116</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_getFrameProgression&quot;);</span></span>
<span id="L1117"><span class="lineNum">    1117</span>                 :<span class="tlaUNC">           0 :     fps.ingested = mtctx-&gt;consumed + mtctx-&gt;inBuff.filled;</span></span>
<span id="L1118"><span class="lineNum">    1118</span>                 :<span class="tlaUNC">           0 :     fps.consumed = mtctx-&gt;consumed;</span></span>
<span id="L1119"><span class="lineNum">    1119</span>                 :<span class="tlaUNC">           0 :     fps.produced = fps.flushed = mtctx-&gt;produced;</span></span>
<span id="L1120"><span class="lineNum">    1120</span>                 :<span class="tlaUNC">           0 :     fps.currentJobID = mtctx-&gt;nextJobID;</span></span>
<span id="L1121"><span class="lineNum">    1121</span>                 :<span class="tlaUNC">           0 :     fps.nbActiveWorkers = 0;</span></span>
<span id="L1122"><span class="lineNum">    1122</span>                 :             :     {   unsigned jobNb;</span>
<span id="L1123"><span class="lineNum">    1123</span>                 :<span class="tlaUNC">           0 :         unsigned lastJobNb = mtctx-&gt;nextJobID + mtctx-&gt;jobReady; assert(mtctx-&gt;jobReady &lt;= 1);</span></span>
<span id="L1124"><span class="lineNum">    1124</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(6, &quot;ZSTDMT_getFrameProgression: jobs: from %u to &lt;%u (jobReady:%u)&quot;,</span></span>
<span id="L1125"><span class="lineNum">    1125</span>                 :             :                     mtctx-&gt;doneJobID, lastJobNb, mtctx-&gt;jobReady);</span>
<span id="L1126"><span class="lineNum">    1126</span>                 :<span class="tlaUNC">           0 :         for (jobNb = mtctx-&gt;doneJobID ; jobNb &lt; lastJobNb ; jobNb++) {</span></span>
<span id="L1127"><span class="lineNum">    1127</span>                 :<span class="tlaUNC">           0 :             unsigned const wJobID = jobNb &amp; mtctx-&gt;jobIDMask;</span></span>
<span id="L1128"><span class="lineNum">    1128</span>                 :<span class="tlaUNC">           0 :             ZSTDMT_jobDescription* jobPtr = &amp;mtctx-&gt;jobs[wJobID];</span></span>
<span id="L1129"><span class="lineNum">    1129</span>                 :<span class="tlaUNC">           0 :             ZSTD_pthread_mutex_lock(&amp;jobPtr-&gt;job_mutex);</span></span>
<span id="L1130"><span class="lineNum">    1130</span>                 :<span class="tlaUNC">           0 :             {   size_t const cResult = jobPtr-&gt;cSize;</span></span>
<span id="L1131"><span class="lineNum">    1131</span>                 :<span class="tlaUNC">           0 :                 size_t const produced = ZSTD_isError(cResult) ? 0 : cResult;</span></span>
<span id="L1132"><span class="lineNum">    1132</span>                 :<span class="tlaUNC">           0 :                 size_t const flushed = ZSTD_isError(cResult) ? 0 : jobPtr-&gt;dstFlushed;</span></span>
<span id="L1133"><span class="lineNum">    1133</span>                 :             :                 assert(flushed &lt;= produced);</span>
<span id="L1134"><span class="lineNum">    1134</span>                 :<span class="tlaUNC">           0 :                 fps.ingested += jobPtr-&gt;src.size;</span></span>
<span id="L1135"><span class="lineNum">    1135</span>                 :<span class="tlaUNC">           0 :                 fps.consumed += jobPtr-&gt;consumed;</span></span>
<span id="L1136"><span class="lineNum">    1136</span>                 :<span class="tlaUNC">           0 :                 fps.produced += produced;</span></span>
<span id="L1137"><span class="lineNum">    1137</span>                 :<span class="tlaUNC">           0 :                 fps.flushed  += flushed;</span></span>
<span id="L1138"><span class="lineNum">    1138</span>                 :<span class="tlaUNC">           0 :                 fps.nbActiveWorkers += (jobPtr-&gt;consumed &lt; jobPtr-&gt;src.size);</span></span>
<span id="L1139"><span class="lineNum">    1139</span>                 :             :             }</span>
<span id="L1140"><span class="lineNum">    1140</span>                 :<span class="tlaUNC">           0 :             ZSTD_pthread_mutex_unlock(&amp;mtctx-&gt;jobs[wJobID].job_mutex);</span></span>
<span id="L1141"><span class="lineNum">    1141</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L1142"><span class="lineNum">    1142</span>                 :             :     }</span>
<span id="L1143"><span class="lineNum">    1143</span>                 :<span class="tlaUNC">           0 :     return fps;</span></span>
<span id="L1144"><span class="lineNum">    1144</span>                 :             : }</span>
<span id="L1145"><span class="lineNum">    1145</span>                 :             : </span>
<span id="L1146"><span class="lineNum">    1146</span>                 :             : </span>
<span id="L1147"><span class="lineNum">    1147</span>                 :<span class="tlaUNC">           0 : size_t ZSTDMT_toFlushNow(ZSTDMT_CCtx* mtctx)</span></span>
<span id="L1148"><span class="lineNum">    1148</span>                 :             : {</span>
<span id="L1149"><span class="lineNum">    1149</span>                 :             :     size_t toFlush;</span>
<span id="L1150"><span class="lineNum">    1150</span>                 :<span class="tlaUNC">           0 :     unsigned const jobID = mtctx-&gt;doneJobID;</span></span>
<span id="L1151"><span class="lineNum">    1151</span>                 :             :     assert(jobID &lt;= mtctx-&gt;nextJobID);</span>
<span id="L1152"><span class="lineNum">    1152</span>                 :<span class="tlaUNC">           0 :     if (jobID == mtctx-&gt;nextJobID) return 0;   /* no active job =&gt; nothing to flush */</span></span>
<span id="L1153"><span class="lineNum">    1153</span>                 :             : </span>
<span id="L1154"><span class="lineNum">    1154</span>                 :             :     /* look into oldest non-fully-flushed job */</span>
<span id="L1155"><span class="lineNum">    1155</span>                 :<span class="tlaUNC">           0 :     {   unsigned const wJobID = jobID &amp; mtctx-&gt;jobIDMask;</span></span>
<span id="L1156"><span class="lineNum">    1156</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_jobDescription* const jobPtr = &amp;mtctx-&gt;jobs[wJobID];</span></span>
<span id="L1157"><span class="lineNum">    1157</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_mutex_lock(&amp;jobPtr-&gt;job_mutex);</span></span>
<span id="L1158"><span class="lineNum">    1158</span>                 :<span class="tlaUNC">           0 :         {   size_t const cResult = jobPtr-&gt;cSize;</span></span>
<span id="L1159"><span class="lineNum">    1159</span>                 :<span class="tlaUNC">           0 :             size_t const produced = ZSTD_isError(cResult) ? 0 : cResult;</span></span>
<span id="L1160"><span class="lineNum">    1160</span>                 :<span class="tlaUNC">           0 :             size_t const flushed = ZSTD_isError(cResult) ? 0 : jobPtr-&gt;dstFlushed;</span></span>
<span id="L1161"><span class="lineNum">    1161</span>                 :             :             assert(flushed &lt;= produced);</span>
<span id="L1162"><span class="lineNum">    1162</span>                 :             :             assert(jobPtr-&gt;consumed &lt;= jobPtr-&gt;src.size);</span>
<span id="L1163"><span class="lineNum">    1163</span>                 :<span class="tlaUNC">           0 :             toFlush = produced - flushed;</span></span>
<span id="L1164"><span class="lineNum">    1164</span>                 :             :             /* if toFlush==0, nothing is available to flush.</span>
<span id="L1165"><span class="lineNum">    1165</span>                 :             :              * However, jobID is expected to still be active:</span>
<span id="L1166"><span class="lineNum">    1166</span>                 :             :              * if jobID was already completed and fully flushed,</span>
<span id="L1167"><span class="lineNum">    1167</span>                 :             :              * ZSTDMT_flushProduced() should have already moved onto next job.</span>
<span id="L1168"><span class="lineNum">    1168</span>                 :             :              * Therefore, some input has not yet been consumed. */</span>
<span id="L1169"><span class="lineNum">    1169</span>                 :<span class="tlaUNC">           0 :             if (toFlush==0) {</span></span>
<span id="L1170"><span class="lineNum">    1170</span>                 :             :                 assert(jobPtr-&gt;consumed &lt; jobPtr-&gt;src.size);</span>
<span id="L1171"><span class="lineNum">    1171</span>                 :<span class="tlaUNC">           0 :             }</span></span>
<span id="L1172"><span class="lineNum">    1172</span>                 :             :         }</span>
<span id="L1173"><span class="lineNum">    1173</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_mutex_unlock(&amp;mtctx-&gt;jobs[wJobID].job_mutex);</span></span>
<span id="L1174"><span class="lineNum">    1174</span>                 :             :     }</span>
<span id="L1175"><span class="lineNum">    1175</span>                 :             : </span>
<span id="L1176"><span class="lineNum">    1176</span>                 :<span class="tlaUNC">           0 :     return toFlush;</span></span>
<span id="L1177"><span class="lineNum">    1177</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1178"><span class="lineNum">    1178</span>                 :             : </span>
<span id="L1179"><span class="lineNum">    1179</span>                 :             : </span>
<span id="L1180"><span class="lineNum">    1180</span>                 :             : /* ------------------------------------------ */</span>
<span id="L1181"><span class="lineNum">    1181</span>                 :             : /* =====   Multi-threaded compression   ===== */</span>
<span id="L1182"><span class="lineNum">    1182</span>                 :             : /* ------------------------------------------ */</span>
<span id="L1183"><span class="lineNum">    1183</span>                 :             : </span>
<span id="L1184"><span class="lineNum">    1184</span>                 :<span class="tlaUNC">           0 : static unsigned ZSTDMT_computeTargetJobLog(const ZSTD_CCtx_params* params)</span></span>
<span id="L1185"><span class="lineNum">    1185</span>                 :             : {</span>
<span id="L1186"><span class="lineNum">    1186</span>                 :             :     unsigned jobLog;</span>
<span id="L1187"><span class="lineNum">    1187</span>                 :<span class="tlaUNC">           0 :     if (params-&gt;ldmParams.enableLdm == ZSTD_ps_enable) {</span></span>
<span id="L1188"><span class="lineNum">    1188</span>                 :             :         /* In Long Range Mode, the windowLog is typically oversized.</span>
<span id="L1189"><span class="lineNum">    1189</span>                 :             :          * In which case, it's preferable to determine the jobSize</span>
<span id="L1190"><span class="lineNum">    1190</span>                 :             :          * based on cycleLog instead. */</span>
<span id="L1191"><span class="lineNum">    1191</span>                 :<span class="tlaUNC">           0 :         jobLog = MAX(21, ZSTD_cycleLog(params-&gt;cParams.chainLog, params-&gt;cParams.strategy) + 3);</span></span>
<span id="L1192"><span class="lineNum">    1192</span>                 :<span class="tlaUNC">           0 :     } else {</span></span>
<span id="L1193"><span class="lineNum">    1193</span>                 :<span class="tlaUNC">           0 :         jobLog = MAX(20, params-&gt;cParams.windowLog + 2);</span></span>
<span id="L1194"><span class="lineNum">    1194</span>                 :             :     }</span>
<span id="L1195"><span class="lineNum">    1195</span>                 :<span class="tlaUNC">           0 :     return MIN(jobLog, (unsigned)ZSTDMT_JOBLOG_MAX);</span></span>
<span id="L1196"><span class="lineNum">    1196</span>                 :             : }</span>
<span id="L1197"><span class="lineNum">    1197</span>                 :             : </span>
<span id="L1198"><span class="lineNum">    1198</span>                 :<span class="tlaUNC">           0 : static int ZSTDMT_overlapLog_default(ZSTD_strategy strat)</span></span>
<span id="L1199"><span class="lineNum">    1199</span>                 :             : {</span>
<span id="L1200"><span class="lineNum">    1200</span>                 :<span class="tlaUNC">           0 :     switch(strat)</span></span>
<span id="L1201"><span class="lineNum">    1201</span>                 :             :     {</span>
<span id="L1202"><span class="lineNum">    1202</span>                 :             :         case ZSTD_btultra2:</span>
<span id="L1203"><span class="lineNum">    1203</span>                 :<span class="tlaUNC">           0 :             return 9;</span></span>
<span id="L1204"><span class="lineNum">    1204</span>                 :             :         case ZSTD_btultra:</span>
<span id="L1205"><span class="lineNum">    1205</span>                 :             :         case ZSTD_btopt:</span>
<span id="L1206"><span class="lineNum">    1206</span>                 :<span class="tlaUNC">           0 :             return 8;</span></span>
<span id="L1207"><span class="lineNum">    1207</span>                 :             :         case ZSTD_btlazy2:</span>
<span id="L1208"><span class="lineNum">    1208</span>                 :             :         case ZSTD_lazy2:</span>
<span id="L1209"><span class="lineNum">    1209</span>                 :<span class="tlaUNC">           0 :             return 7;</span></span>
<span id="L1210"><span class="lineNum">    1210</span>                 :             :         case ZSTD_lazy:</span>
<span id="L1211"><span class="lineNum">    1211</span>                 :             :         case ZSTD_greedy:</span>
<span id="L1212"><span class="lineNum">    1212</span>                 :             :         case ZSTD_dfast:</span>
<span id="L1213"><span class="lineNum">    1213</span>                 :<span class="tlaUNC">           0 :         case ZSTD_fast:</span></span>
<span id="L1214"><span class="lineNum">    1214</span>                 :             :         default:;</span>
<span id="L1215"><span class="lineNum">    1215</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1216"><span class="lineNum">    1216</span>                 :<span class="tlaUNC">           0 :     return 6;</span></span>
<span id="L1217"><span class="lineNum">    1217</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1218"><span class="lineNum">    1218</span>                 :             : </span>
<span id="L1219"><span class="lineNum">    1219</span>                 :<span class="tlaUNC">           0 : static int ZSTDMT_overlapLog(int ovlog, ZSTD_strategy strat)</span></span>
<span id="L1220"><span class="lineNum">    1220</span>                 :             : {</span>
<span id="L1221"><span class="lineNum">    1221</span>                 :             :     assert(0 &lt;= ovlog &amp;&amp; ovlog &lt;= 9);</span>
<span id="L1222"><span class="lineNum">    1222</span>                 :<span class="tlaUNC">           0 :     if (ovlog == 0) return ZSTDMT_overlapLog_default(strat);</span></span>
<span id="L1223"><span class="lineNum">    1223</span>                 :<span class="tlaUNC">           0 :     return ovlog;</span></span>
<span id="L1224"><span class="lineNum">    1224</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1225"><span class="lineNum">    1225</span>                 :             : </span>
<span id="L1226"><span class="lineNum">    1226</span>                 :<span class="tlaUNC">           0 : static size_t ZSTDMT_computeOverlapSize(const ZSTD_CCtx_params* params)</span></span>
<span id="L1227"><span class="lineNum">    1227</span>                 :             : {</span>
<span id="L1228"><span class="lineNum">    1228</span>                 :<span class="tlaUNC">           0 :     int const overlapRLog = 9 - ZSTDMT_overlapLog(params-&gt;overlapLog, params-&gt;cParams.strategy);</span></span>
<span id="L1229"><span class="lineNum">    1229</span>                 :<span class="tlaUNC">           0 :     int ovLog = (overlapRLog &gt;= 8) ? 0 : (params-&gt;cParams.windowLog - overlapRLog);</span></span>
<span id="L1230"><span class="lineNum">    1230</span>                 :             :     assert(0 &lt;= overlapRLog &amp;&amp; overlapRLog &lt;= 8);</span>
<span id="L1231"><span class="lineNum">    1231</span>                 :<span class="tlaUNC">           0 :     if (params-&gt;ldmParams.enableLdm == ZSTD_ps_enable) {</span></span>
<span id="L1232"><span class="lineNum">    1232</span>                 :             :         /* In Long Range Mode, the windowLog is typically oversized.</span>
<span id="L1233"><span class="lineNum">    1233</span>                 :             :          * In which case, it's preferable to determine the jobSize</span>
<span id="L1234"><span class="lineNum">    1234</span>                 :             :          * based on chainLog instead.</span>
<span id="L1235"><span class="lineNum">    1235</span>                 :             :          * Then, ovLog becomes a fraction of the jobSize, rather than windowSize */</span>
<span id="L1236"><span class="lineNum">    1236</span>                 :<span class="tlaUNC">           0 :         ovLog = MIN(params-&gt;cParams.windowLog, ZSTDMT_computeTargetJobLog(params) - 2)</span></span>
<span id="L1237"><span class="lineNum">    1237</span>                 :<span class="tlaUNC">           0 :                 - overlapRLog;</span></span>
<span id="L1238"><span class="lineNum">    1238</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1239"><span class="lineNum">    1239</span>                 :             :     assert(0 &lt;= ovLog &amp;&amp; ovLog &lt;= ZSTD_WINDOWLOG_MAX);</span>
<span id="L1240"><span class="lineNum">    1240</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(4, &quot;overlapLog : %i&quot;, params-&gt;overlapLog);</span></span>
<span id="L1241"><span class="lineNum">    1241</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(4, &quot;overlap size : %i&quot;, 1 &lt;&lt; ovLog);</span></span>
<span id="L1242"><span class="lineNum">    1242</span>                 :<span class="tlaUNC">           0 :     return (ovLog==0) ? 0 : (size_t)1 &lt;&lt; ovLog;</span></span>
<span id="L1243"><span class="lineNum">    1243</span>                 :             : }</span>
<span id="L1244"><span class="lineNum">    1244</span>                 :             : </span>
<span id="L1245"><span class="lineNum">    1245</span>                 :             : /* ====================================== */</span>
<span id="L1246"><span class="lineNum">    1246</span>                 :             : /* =======      Streaming API     ======= */</span>
<span id="L1247"><span class="lineNum">    1247</span>                 :             : /* ====================================== */</span>
<span id="L1248"><span class="lineNum">    1248</span>                 :             : </span>
<span id="L1249"><span class="lineNum">    1249</span>                 :<span class="tlaUNC">           0 : size_t ZSTDMT_initCStream_internal(</span></span>
<span id="L1250"><span class="lineNum">    1250</span>                 :             :         ZSTDMT_CCtx* mtctx,</span>
<span id="L1251"><span class="lineNum">    1251</span>                 :             :         const void* dict, size_t dictSize, ZSTD_dictContentType_e dictContentType,</span>
<span id="L1252"><span class="lineNum">    1252</span>                 :             :         const ZSTD_CDict* cdict, ZSTD_CCtx_params params,</span>
<span id="L1253"><span class="lineNum">    1253</span>                 :             :         unsigned long long pledgedSrcSize)</span>
<span id="L1254"><span class="lineNum">    1254</span>                 :             : {</span>
<span id="L1255"><span class="lineNum">    1255</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(4, &quot;ZSTDMT_initCStream_internal (pledgedSrcSize=%u, nbWorkers=%u, cctxPool=%u)&quot;,</span></span>
<span id="L1256"><span class="lineNum">    1256</span>                 :             :                 (U32)pledgedSrcSize, params.nbWorkers, mtctx-&gt;cctxPool-&gt;totalCCtx);</span>
<span id="L1257"><span class="lineNum">    1257</span>                 :             : </span>
<span id="L1258"><span class="lineNum">    1258</span>                 :             :     /* params supposed partially fully validated at this point */</span>
<span id="L1259"><span class="lineNum">    1259</span>                 :             :     assert(!ZSTD_isError(ZSTD_checkCParams(params.cParams)));</span>
<span id="L1260"><span class="lineNum">    1260</span>                 :             :     assert(!((dict) &amp;&amp; (cdict)));  /* either dict or cdict, not both */</span>
<span id="L1261"><span class="lineNum">    1261</span>                 :             : </span>
<span id="L1262"><span class="lineNum">    1262</span>                 :             :     /* init */</span>
<span id="L1263"><span class="lineNum">    1263</span>                 :<span class="tlaUNC">           0 :     if (params.nbWorkers != mtctx-&gt;params.nbWorkers)</span></span>
<span id="L1264"><span class="lineNum">    1264</span>                 :<span class="tlaUNC">           0 :         FORWARD_IF_ERROR( ZSTDMT_resize(mtctx, (unsigned)params.nbWorkers) , &quot;&quot;);</span></span>
<span id="L1265"><span class="lineNum">    1265</span>                 :             : </span>
<span id="L1266"><span class="lineNum">    1266</span>                 :<span class="tlaUNC">           0 :     if (params.jobSize != 0 &amp;&amp; params.jobSize &lt; ZSTDMT_JOBSIZE_MIN) params.jobSize = ZSTDMT_JOBSIZE_MIN;</span></span>
<span id="L1267"><span class="lineNum">    1267</span>                 :<span class="tlaUNC">           0 :     if (params.jobSize &gt; (size_t)ZSTDMT_JOBSIZE_MAX) params.jobSize = (size_t)ZSTDMT_JOBSIZE_MAX;</span></span>
<span id="L1268"><span class="lineNum">    1268</span>                 :             : </span>
<span id="L1269"><span class="lineNum">    1269</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;allJobsCompleted == 0) {   /* previous compression not correctly finished */</span></span>
<span id="L1270"><span class="lineNum">    1270</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_waitForAllJobsCompleted(mtctx);</span></span>
<span id="L1271"><span class="lineNum">    1271</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_releaseAllJobResources(mtctx);</span></span>
<span id="L1272"><span class="lineNum">    1272</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;allJobsCompleted = 1;</span></span>
<span id="L1273"><span class="lineNum">    1273</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1274"><span class="lineNum">    1274</span>                 :             : </span>
<span id="L1275"><span class="lineNum">    1275</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;params = params;</span></span>
<span id="L1276"><span class="lineNum">    1276</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;frameContentSize = pledgedSrcSize;</span></span>
<span id="L1277"><span class="lineNum">    1277</span>                 :<span class="tlaUNC">           0 :     ZSTD_freeCDict(mtctx-&gt;cdictLocal);</span></span>
<span id="L1278"><span class="lineNum">    1278</span>                 :<span class="tlaUNC">           0 :     if (dict) {</span></span>
<span id="L1279"><span class="lineNum">    1279</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;cdictLocal = ZSTD_createCDict_advanced(dict, dictSize,</span></span>
<span id="L1280"><span class="lineNum">    1280</span>                 :<span class="tlaUNC">           0 :                                                     ZSTD_dlm_byCopy, dictContentType, /* note : a loadPrefix becomes an internal CDict */</span></span>
<span id="L1281"><span class="lineNum">    1281</span>                 :<span class="tlaUNC">           0 :                                                     params.cParams, mtctx-&gt;cMem);</span></span>
<span id="L1282"><span class="lineNum">    1282</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;cdict = mtctx-&gt;cdictLocal;</span></span>
<span id="L1283"><span class="lineNum">    1283</span>                 :<span class="tlaUNC">           0 :         if (mtctx-&gt;cdictLocal == NULL) return ERROR(memory_allocation);</span></span>
<span id="L1284"><span class="lineNum">    1284</span>                 :<span class="tlaUNC">           0 :     } else {</span></span>
<span id="L1285"><span class="lineNum">    1285</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;cdictLocal = NULL;</span></span>
<span id="L1286"><span class="lineNum">    1286</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;cdict = cdict;</span></span>
<span id="L1287"><span class="lineNum">    1287</span>                 :             :     }</span>
<span id="L1288"><span class="lineNum">    1288</span>                 :             : </span>
<span id="L1289"><span class="lineNum">    1289</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;targetPrefixSize = ZSTDMT_computeOverlapSize(&amp;params);</span></span>
<span id="L1290"><span class="lineNum">    1290</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(4, &quot;overlapLog=%i =&gt; %u KB&quot;, params.overlapLog, (U32)(mtctx-&gt;targetPrefixSize&gt;&gt;10));</span></span>
<span id="L1291"><span class="lineNum">    1291</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;targetSectionSize = params.jobSize;</span></span>
<span id="L1292"><span class="lineNum">    1292</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;targetSectionSize == 0) {</span></span>
<span id="L1293"><span class="lineNum">    1293</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;targetSectionSize = 1ULL &lt;&lt; ZSTDMT_computeTargetJobLog(&amp;params);</span></span>
<span id="L1294"><span class="lineNum">    1294</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1295"><span class="lineNum">    1295</span>                 :             :     assert(mtctx-&gt;targetSectionSize &lt;= (size_t)ZSTDMT_JOBSIZE_MAX);</span>
<span id="L1296"><span class="lineNum">    1296</span>                 :             : </span>
<span id="L1297"><span class="lineNum">    1297</span>                 :<span class="tlaUNC">           0 :     if (params.rsyncable) {</span></span>
<span id="L1298"><span class="lineNum">    1298</span>                 :             :         /* Aim for the targetsectionSize as the average job size. */</span>
<span id="L1299"><span class="lineNum">    1299</span>                 :<span class="tlaUNC">           0 :         U32 const jobSizeKB = (U32)(mtctx-&gt;targetSectionSize &gt;&gt; 10);</span></span>
<span id="L1300"><span class="lineNum">    1300</span>                 :<span class="tlaUNC">           0 :         U32 const rsyncBits = (assert(jobSizeKB &gt;= 1), ZSTD_highbit32(jobSizeKB) + 10);</span></span>
<span id="L1301"><span class="lineNum">    1301</span>                 :             :         /* We refuse to create jobs &lt; RSYNC_MIN_BLOCK_SIZE bytes, so make sure our</span>
<span id="L1302"><span class="lineNum">    1302</span>                 :             :          * expected job size is at least 4x larger. */</span>
<span id="L1303"><span class="lineNum">    1303</span>                 :             :         assert(rsyncBits &gt;= RSYNC_MIN_BLOCK_LOG + 2);</span>
<span id="L1304"><span class="lineNum">    1304</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(4, &quot;rsyncLog = %u&quot;, rsyncBits);</span></span>
<span id="L1305"><span class="lineNum">    1305</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;rsync.hash = 0;</span></span>
<span id="L1306"><span class="lineNum">    1306</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;rsync.hitMask = (1ULL &lt;&lt; rsyncBits) - 1;</span></span>
<span id="L1307"><span class="lineNum">    1307</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;rsync.primePower = ZSTD_rollingHash_primePower(RSYNC_LENGTH);</span></span>
<span id="L1308"><span class="lineNum">    1308</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1309"><span class="lineNum">    1309</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;targetSectionSize &lt; mtctx-&gt;targetPrefixSize) mtctx-&gt;targetSectionSize = mtctx-&gt;targetPrefixSize;  /* job size must be &gt;= overlap size */</span></span>
<span id="L1310"><span class="lineNum">    1310</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(4, &quot;Job Size : %u KB (note : set to %u)&quot;, (U32)(mtctx-&gt;targetSectionSize&gt;&gt;10), (U32)params.jobSize);</span></span>
<span id="L1311"><span class="lineNum">    1311</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(4, &quot;inBuff Size : %u KB&quot;, (U32)(mtctx-&gt;targetSectionSize&gt;&gt;10));</span></span>
<span id="L1312"><span class="lineNum">    1312</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_setBufferSize(mtctx-&gt;bufPool, ZSTD_compressBound(mtctx-&gt;targetSectionSize));</span></span>
<span id="L1313"><span class="lineNum">    1313</span>                 :             :     {</span>
<span id="L1314"><span class="lineNum">    1314</span>                 :             :         /* If ldm is enabled we need windowSize space. */</span>
<span id="L1315"><span class="lineNum">    1315</span>                 :<span class="tlaUNC">           0 :         size_t const windowSize = mtctx-&gt;params.ldmParams.enableLdm == ZSTD_ps_enable ? (1U &lt;&lt; mtctx-&gt;params.cParams.windowLog) : 0;</span></span>
<span id="L1316"><span class="lineNum">    1316</span>                 :             :         /* Two buffers of slack, plus extra space for the overlap</span>
<span id="L1317"><span class="lineNum">    1317</span>                 :             :          * This is the minimum slack that LDM works with. One extra because</span>
<span id="L1318"><span class="lineNum">    1318</span>                 :             :          * flush might waste up to targetSectionSize-1 bytes. Another extra</span>
<span id="L1319"><span class="lineNum">    1319</span>                 :             :          * for the overlap (if &gt; 0), then one to fill which doesn't overlap</span>
<span id="L1320"><span class="lineNum">    1320</span>                 :             :          * with the LDM window.</span>
<span id="L1321"><span class="lineNum">    1321</span>                 :             :          */</span>
<span id="L1322"><span class="lineNum">    1322</span>                 :<span class="tlaUNC">           0 :         size_t const nbSlackBuffers = 2 + (mtctx-&gt;targetPrefixSize &gt; 0);</span></span>
<span id="L1323"><span class="lineNum">    1323</span>                 :<span class="tlaUNC">           0 :         size_t const slackSize = mtctx-&gt;targetSectionSize * nbSlackBuffers;</span></span>
<span id="L1324"><span class="lineNum">    1324</span>                 :             :         /* Compute the total size, and always have enough slack */</span>
<span id="L1325"><span class="lineNum">    1325</span>                 :<span class="tlaUNC">           0 :         size_t const nbWorkers = MAX(mtctx-&gt;params.nbWorkers, 1);</span></span>
<span id="L1326"><span class="lineNum">    1326</span>                 :<span class="tlaUNC">           0 :         size_t const sectionsSize = mtctx-&gt;targetSectionSize * nbWorkers;</span></span>
<span id="L1327"><span class="lineNum">    1327</span>                 :<span class="tlaUNC">           0 :         size_t const capacity = MAX(windowSize, sectionsSize) + slackSize;</span></span>
<span id="L1328"><span class="lineNum">    1328</span>                 :<span class="tlaUNC">           0 :         if (mtctx-&gt;roundBuff.capacity &lt; capacity) {</span></span>
<span id="L1329"><span class="lineNum">    1329</span>                 :<span class="tlaUNC">           0 :             if (mtctx-&gt;roundBuff.buffer)</span></span>
<span id="L1330"><span class="lineNum">    1330</span>                 :<span class="tlaUNC">           0 :                 ZSTD_customFree(mtctx-&gt;roundBuff.buffer, mtctx-&gt;cMem);</span></span>
<span id="L1331"><span class="lineNum">    1331</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;roundBuff.buffer = (BYTE*)ZSTD_customMalloc(capacity, mtctx-&gt;cMem);</span></span>
<span id="L1332"><span class="lineNum">    1332</span>                 :<span class="tlaUNC">           0 :             if (mtctx-&gt;roundBuff.buffer == NULL) {</span></span>
<span id="L1333"><span class="lineNum">    1333</span>                 :<span class="tlaUNC">           0 :                 mtctx-&gt;roundBuff.capacity = 0;</span></span>
<span id="L1334"><span class="lineNum">    1334</span>                 :<span class="tlaUNC">           0 :                 return ERROR(memory_allocation);</span></span>
<span id="L1335"><span class="lineNum">    1335</span>                 :             :             }</span>
<span id="L1336"><span class="lineNum">    1336</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;roundBuff.capacity = capacity;</span></span>
<span id="L1337"><span class="lineNum">    1337</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L1338"><span class="lineNum">    1338</span>                 :             :     }</span>
<span id="L1339"><span class="lineNum">    1339</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(4, &quot;roundBuff capacity : %u KB&quot;, (U32)(mtctx-&gt;roundBuff.capacity&gt;&gt;10));</span></span>
<span id="L1340"><span class="lineNum">    1340</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;roundBuff.pos = 0;</span></span>
<span id="L1341"><span class="lineNum">    1341</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;inBuff.buffer = g_nullBuffer;</span></span>
<span id="L1342"><span class="lineNum">    1342</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;inBuff.filled = 0;</span></span>
<span id="L1343"><span class="lineNum">    1343</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;inBuff.prefix = kNullRange;</span></span>
<span id="L1344"><span class="lineNum">    1344</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;doneJobID = 0;</span></span>
<span id="L1345"><span class="lineNum">    1345</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;nextJobID = 0;</span></span>
<span id="L1346"><span class="lineNum">    1346</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;frameEnded = 0;</span></span>
<span id="L1347"><span class="lineNum">    1347</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;allJobsCompleted = 0;</span></span>
<span id="L1348"><span class="lineNum">    1348</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;consumed = 0;</span></span>
<span id="L1349"><span class="lineNum">    1349</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;produced = 0;</span></span>
<span id="L1350"><span class="lineNum">    1350</span>                 :             : </span>
<span id="L1351"><span class="lineNum">    1351</span>                 :             :     /* update dictionary */</span>
<span id="L1352"><span class="lineNum">    1352</span>                 :<span class="tlaUNC">           0 :     ZSTD_freeCDict(mtctx-&gt;cdictLocal);</span></span>
<span id="L1353"><span class="lineNum">    1353</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;cdictLocal = NULL;</span></span>
<span id="L1354"><span class="lineNum">    1354</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;cdict = NULL;</span></span>
<span id="L1355"><span class="lineNum">    1355</span>                 :<span class="tlaUNC">           0 :     if (dict) {</span></span>
<span id="L1356"><span class="lineNum">    1356</span>                 :<span class="tlaUNC">           0 :         if (dictContentType == ZSTD_dct_rawContent) {</span></span>
<span id="L1357"><span class="lineNum">    1357</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;inBuff.prefix.start = (const BYTE*)dict;</span></span>
<span id="L1358"><span class="lineNum">    1358</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;inBuff.prefix.size = dictSize;</span></span>
<span id="L1359"><span class="lineNum">    1359</span>                 :<span class="tlaUNC">           0 :         } else {</span></span>
<span id="L1360"><span class="lineNum">    1360</span>                 :             :             /* note : a loadPrefix becomes an internal CDict */</span>
<span id="L1361"><span class="lineNum">    1361</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;cdictLocal = ZSTD_createCDict_advanced(dict, dictSize,</span></span>
<span id="L1362"><span class="lineNum">    1362</span>                 :<span class="tlaUNC">           0 :                                                         ZSTD_dlm_byRef, dictContentType,</span></span>
<span id="L1363"><span class="lineNum">    1363</span>                 :<span class="tlaUNC">           0 :                                                         params.cParams, mtctx-&gt;cMem);</span></span>
<span id="L1364"><span class="lineNum">    1364</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;cdict = mtctx-&gt;cdictLocal;</span></span>
<span id="L1365"><span class="lineNum">    1365</span>                 :<span class="tlaUNC">           0 :             if (mtctx-&gt;cdictLocal == NULL) return ERROR(memory_allocation);</span></span>
<span id="L1366"><span class="lineNum">    1366</span>                 :             :         }</span>
<span id="L1367"><span class="lineNum">    1367</span>                 :<span class="tlaUNC">           0 :     } else {</span></span>
<span id="L1368"><span class="lineNum">    1368</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;cdict = cdict;</span></span>
<span id="L1369"><span class="lineNum">    1369</span>                 :             :     }</span>
<span id="L1370"><span class="lineNum">    1370</span>                 :             : </span>
<span id="L1371"><span class="lineNum">    1371</span>                 :<span class="tlaUNC">           0 :     if (ZSTDMT_serialState_reset(&amp;mtctx-&gt;serial, mtctx-&gt;seqPool, params, mtctx-&gt;targetSectionSize,</span></span>
<span id="L1372"><span class="lineNum">    1372</span>                 :<span class="tlaUNC">           0 :                                  dict, dictSize, dictContentType))</span></span>
<span id="L1373"><span class="lineNum">    1373</span>                 :<span class="tlaUNC">           0 :         return ERROR(memory_allocation);</span></span>
<span id="L1374"><span class="lineNum">    1374</span>                 :             : </span>
<span id="L1375"><span class="lineNum">    1375</span>                 :             : </span>
<span id="L1376"><span class="lineNum">    1376</span>                 :<span class="tlaUNC">           0 :     return 0;</span></span>
<span id="L1377"><span class="lineNum">    1377</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1378"><span class="lineNum">    1378</span>                 :             : </span>
<span id="L1379"><span class="lineNum">    1379</span>                 :             : </span>
<span id="L1380"><span class="lineNum">    1380</span>                 :             : /* ZSTDMT_writeLastEmptyBlock()</span>
<span id="L1381"><span class="lineNum">    1381</span>                 :             :  * Write a single empty block with an end-of-frame to finish a frame.</span>
<span id="L1382"><span class="lineNum">    1382</span>                 :             :  * Job must be created from streaming variant.</span>
<span id="L1383"><span class="lineNum">    1383</span>                 :             :  * This function is always successful if expected conditions are fulfilled.</span>
<span id="L1384"><span class="lineNum">    1384</span>                 :             :  */</span>
<span id="L1385"><span class="lineNum">    1385</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_writeLastEmptyBlock(ZSTDMT_jobDescription* job)</span></span>
<span id="L1386"><span class="lineNum">    1386</span>                 :             : {</span>
<span id="L1387"><span class="lineNum">    1387</span>                 :             :     assert(job-&gt;lastJob == 1);</span>
<span id="L1388"><span class="lineNum">    1388</span>                 :             :     assert(job-&gt;src.size == 0);   /* last job is empty -&gt; will be simplified into a last empty block */</span>
<span id="L1389"><span class="lineNum">    1389</span>                 :             :     assert(job-&gt;firstJob == 0);   /* cannot be first job, as it also needs to create frame header */</span>
<span id="L1390"><span class="lineNum">    1390</span>                 :             :     assert(job-&gt;dstBuff.start == NULL);   /* invoked from streaming variant only (otherwise, dstBuff might be user's output) */</span>
<span id="L1391"><span class="lineNum">    1391</span>                 :<span class="tlaUNC">           0 :     job-&gt;dstBuff = ZSTDMT_getBuffer(job-&gt;bufPool);</span></span>
<span id="L1392"><span class="lineNum">    1392</span>                 :<span class="tlaUNC">           0 :     if (job-&gt;dstBuff.start == NULL) {</span></span>
<span id="L1393"><span class="lineNum">    1393</span>                 :<span class="tlaUNC">           0 :       job-&gt;cSize = ERROR(memory_allocation);</span></span>
<span id="L1394"><span class="lineNum">    1394</span>                 :<span class="tlaUNC">           0 :       return;</span></span>
<span id="L1395"><span class="lineNum">    1395</span>                 :             :     }</span>
<span id="L1396"><span class="lineNum">    1396</span>                 :             :     assert(job-&gt;dstBuff.capacity &gt;= ZSTD_blockHeaderSize);   /* no buffer should ever be that small */</span>
<span id="L1397"><span class="lineNum">    1397</span>                 :<span class="tlaUNC">           0 :     job-&gt;src = kNullRange;</span></span>
<span id="L1398"><span class="lineNum">    1398</span>                 :<span class="tlaUNC">           0 :     job-&gt;cSize = ZSTD_writeLastEmptyBlock(job-&gt;dstBuff.start, job-&gt;dstBuff.capacity);</span></span>
<span id="L1399"><span class="lineNum">    1399</span>                 :             :     assert(!ZSTD_isError(job-&gt;cSize));</span>
<span id="L1400"><span class="lineNum">    1400</span>                 :             :     assert(job-&gt;consumed == 0);</span>
<span id="L1401"><span class="lineNum">    1401</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1402"><span class="lineNum">    1402</span>                 :             : </span>
<span id="L1403"><span class="lineNum">    1403</span>                 :<span class="tlaUNC">           0 : static size_t ZSTDMT_createCompressionJob(ZSTDMT_CCtx* mtctx, size_t srcSize, ZSTD_EndDirective endOp)</span></span>
<span id="L1404"><span class="lineNum">    1404</span>                 :             : {</span>
<span id="L1405"><span class="lineNum">    1405</span>                 :<span class="tlaUNC">           0 :     unsigned const jobID = mtctx-&gt;nextJobID &amp; mtctx-&gt;jobIDMask;</span></span>
<span id="L1406"><span class="lineNum">    1406</span>                 :<span class="tlaUNC">           0 :     int const endFrame = (endOp == ZSTD_e_end);</span></span>
<span id="L1407"><span class="lineNum">    1407</span>                 :             : </span>
<span id="L1408"><span class="lineNum">    1408</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;nextJobID &gt; mtctx-&gt;doneJobID + mtctx-&gt;jobIDMask) {</span></span>
<span id="L1409"><span class="lineNum">    1409</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;ZSTDMT_createCompressionJob: will not create new job : table is full&quot;);</span></span>
<span id="L1410"><span class="lineNum">    1410</span>                 :             :         assert((mtctx-&gt;nextJobID &amp; mtctx-&gt;jobIDMask) == (mtctx-&gt;doneJobID &amp; mtctx-&gt;jobIDMask));</span>
<span id="L1411"><span class="lineNum">    1411</span>                 :<span class="tlaUNC">           0 :         return 0;</span></span>
<span id="L1412"><span class="lineNum">    1412</span>                 :             :     }</span>
<span id="L1413"><span class="lineNum">    1413</span>                 :             : </span>
<span id="L1414"><span class="lineNum">    1414</span>                 :<span class="tlaUNC">           0 :     if (!mtctx-&gt;jobReady) {</span></span>
<span id="L1415"><span class="lineNum">    1415</span>                 :<span class="tlaUNC">           0 :         BYTE const* src = (BYTE const*)mtctx-&gt;inBuff.buffer.start;</span></span>
<span id="L1416"><span class="lineNum">    1416</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;ZSTDMT_createCompressionJob: preparing job %u to compress %u bytes with %u preload &quot;,</span></span>
<span id="L1417"><span class="lineNum">    1417</span>                 :             :                     mtctx-&gt;nextJobID, (U32)srcSize, (U32)mtctx-&gt;inBuff.prefix.size);</span>
<span id="L1418"><span class="lineNum">    1418</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].src.start = src;</span></span>
<span id="L1419"><span class="lineNum">    1419</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].src.size = srcSize;</span></span>
<span id="L1420"><span class="lineNum">    1420</span>                 :             :         assert(mtctx-&gt;inBuff.filled &gt;= srcSize);</span>
<span id="L1421"><span class="lineNum">    1421</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].prefix = mtctx-&gt;inBuff.prefix;</span></span>
<span id="L1422"><span class="lineNum">    1422</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].consumed = 0;</span></span>
<span id="L1423"><span class="lineNum">    1423</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].cSize = 0;</span></span>
<span id="L1424"><span class="lineNum">    1424</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].params = mtctx-&gt;params;</span></span>
<span id="L1425"><span class="lineNum">    1425</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].cdict = mtctx-&gt;nextJobID==0 ? mtctx-&gt;cdict : NULL;</span></span>
<span id="L1426"><span class="lineNum">    1426</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].fullFrameSize = mtctx-&gt;frameContentSize;</span></span>
<span id="L1427"><span class="lineNum">    1427</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].dstBuff = g_nullBuffer;</span></span>
<span id="L1428"><span class="lineNum">    1428</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].cctxPool = mtctx-&gt;cctxPool;</span></span>
<span id="L1429"><span class="lineNum">    1429</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].bufPool = mtctx-&gt;bufPool;</span></span>
<span id="L1430"><span class="lineNum">    1430</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].seqPool = mtctx-&gt;seqPool;</span></span>
<span id="L1431"><span class="lineNum">    1431</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].serial = &amp;mtctx-&gt;serial;</span></span>
<span id="L1432"><span class="lineNum">    1432</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].jobID = mtctx-&gt;nextJobID;</span></span>
<span id="L1433"><span class="lineNum">    1433</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].firstJob = (mtctx-&gt;nextJobID==0);</span></span>
<span id="L1434"><span class="lineNum">    1434</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].lastJob = endFrame;</span></span>
<span id="L1435"><span class="lineNum">    1435</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].frameChecksumNeeded = mtctx-&gt;params.fParams.checksumFlag &amp;&amp; endFrame &amp;&amp; (mtctx-&gt;nextJobID&gt;0);</span></span>
<span id="L1436"><span class="lineNum">    1436</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobs[jobID].dstFlushed = 0;</span></span>
<span id="L1437"><span class="lineNum">    1437</span>                 :             : </span>
<span id="L1438"><span class="lineNum">    1438</span>                 :             :         /* Update the round buffer pos and clear the input buffer to be reset */</span>
<span id="L1439"><span class="lineNum">    1439</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;roundBuff.pos += srcSize;</span></span>
<span id="L1440"><span class="lineNum">    1440</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;inBuff.buffer = g_nullBuffer;</span></span>
<span id="L1441"><span class="lineNum">    1441</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;inBuff.filled = 0;</span></span>
<span id="L1442"><span class="lineNum">    1442</span>                 :             :         /* Set the prefix for next job */</span>
<span id="L1443"><span class="lineNum">    1443</span>                 :<span class="tlaUNC">           0 :         if (!endFrame) {</span></span>
<span id="L1444"><span class="lineNum">    1444</span>                 :<span class="tlaUNC">           0 :             size_t const newPrefixSize = MIN(srcSize, mtctx-&gt;targetPrefixSize);</span></span>
<span id="L1445"><span class="lineNum">    1445</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;inBuff.prefix.start = src + srcSize - newPrefixSize;</span></span>
<span id="L1446"><span class="lineNum">    1446</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;inBuff.prefix.size = newPrefixSize;</span></span>
<span id="L1447"><span class="lineNum">    1447</span>                 :<span class="tlaUNC">           0 :         } else {   /* endFrame==1 =&gt; no need for another input buffer */</span></span>
<span id="L1448"><span class="lineNum">    1448</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;inBuff.prefix = kNullRange;</span></span>
<span id="L1449"><span class="lineNum">    1449</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;frameEnded = endFrame;</span></span>
<span id="L1450"><span class="lineNum">    1450</span>                 :<span class="tlaUNC">           0 :             if (mtctx-&gt;nextJobID == 0) {</span></span>
<span id="L1451"><span class="lineNum">    1451</span>                 :             :                 /* single job exception : checksum is already calculated directly within worker thread */</span>
<span id="L1452"><span class="lineNum">    1452</span>                 :<span class="tlaUNC">           0 :                 mtctx-&gt;params.fParams.checksumFlag = 0;</span></span>
<span id="L1453"><span class="lineNum">    1453</span>                 :<span class="tlaUNC">           0 :         }   }</span></span>
<span id="L1454"><span class="lineNum">    1454</span>                 :             : </span>
<span id="L1455"><span class="lineNum">    1455</span>                 :<span class="tlaUNC">           0 :         if ( (srcSize == 0)</span></span>
<span id="L1456"><span class="lineNum">    1456</span>                 :<span class="tlaUNC">           0 :           &amp;&amp; (mtctx-&gt;nextJobID&gt;0)/*single job must also write frame header*/ ) {</span></span>
<span id="L1457"><span class="lineNum">    1457</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(5, &quot;ZSTDMT_createCompressionJob: creating a last empty block to end frame&quot;);</span></span>
<span id="L1458"><span class="lineNum">    1458</span>                 :             :             assert(endOp == ZSTD_e_end);  /* only possible case : need to end the frame with an empty last block */</span>
<span id="L1459"><span class="lineNum">    1459</span>                 :<span class="tlaUNC">           0 :             ZSTDMT_writeLastEmptyBlock(mtctx-&gt;jobs + jobID);</span></span>
<span id="L1460"><span class="lineNum">    1460</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;nextJobID++;</span></span>
<span id="L1461"><span class="lineNum">    1461</span>                 :<span class="tlaUNC">           0 :             return 0;</span></span>
<span id="L1462"><span class="lineNum">    1462</span>                 :             :         }</span>
<span id="L1463"><span class="lineNum">    1463</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1464"><span class="lineNum">    1464</span>                 :             : </span>
<span id="L1465"><span class="lineNum">    1465</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_createCompressionJob: posting job %u : %u bytes  (end:%u, jobNb == %u (mod:%u))&quot;,</span></span>
<span id="L1466"><span class="lineNum">    1466</span>                 :             :                 mtctx-&gt;nextJobID,</span>
<span id="L1467"><span class="lineNum">    1467</span>                 :             :                 (U32)mtctx-&gt;jobs[jobID].src.size,</span>
<span id="L1468"><span class="lineNum">    1468</span>                 :             :                 mtctx-&gt;jobs[jobID].lastJob,</span>
<span id="L1469"><span class="lineNum">    1469</span>                 :             :                 mtctx-&gt;nextJobID,</span>
<span id="L1470"><span class="lineNum">    1470</span>                 :             :                 jobID);</span>
<span id="L1471"><span class="lineNum">    1471</span>                 :<span class="tlaUNC">           0 :     if (POOL_tryAdd(mtctx-&gt;factory, ZSTDMT_compressionJob, &amp;mtctx-&gt;jobs[jobID])) {</span></span>
<span id="L1472"><span class="lineNum">    1472</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;nextJobID++;</span></span>
<span id="L1473"><span class="lineNum">    1473</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobReady = 0;</span></span>
<span id="L1474"><span class="lineNum">    1474</span>                 :<span class="tlaUNC">           0 :     } else {</span></span>
<span id="L1475"><span class="lineNum">    1475</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;ZSTDMT_createCompressionJob: no worker available for job %u&quot;, mtctx-&gt;nextJobID);</span></span>
<span id="L1476"><span class="lineNum">    1476</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;jobReady = 1;</span></span>
<span id="L1477"><span class="lineNum">    1477</span>                 :             :     }</span>
<span id="L1478"><span class="lineNum">    1478</span>                 :<span class="tlaUNC">           0 :     return 0;</span></span>
<span id="L1479"><span class="lineNum">    1479</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1480"><span class="lineNum">    1480</span>                 :             : </span>
<span id="L1481"><span class="lineNum">    1481</span>                 :             : </span>
<span id="L1482"><span class="lineNum">    1482</span>                 :             : /*! ZSTDMT_flushProduced() :</span>
<span id="L1483"><span class="lineNum">    1483</span>                 :             :  *  flush whatever data has been produced but not yet flushed in current job.</span>
<span id="L1484"><span class="lineNum">    1484</span>                 :             :  *  move to next job if current one is fully flushed.</span>
<span id="L1485"><span class="lineNum">    1485</span>                 :             :  * `output` : `pos` will be updated with amount of data flushed .</span>
<span id="L1486"><span class="lineNum">    1486</span>                 :             :  * `blockToFlush` : if &gt;0, the function will block and wait if there is no data available to flush .</span>
<span id="L1487"><span class="lineNum">    1487</span>                 :             :  * @return : amount of data remaining within internal buffer, 0 if no more, 1 if unknown but &gt; 0, or an error code */</span>
<span id="L1488"><span class="lineNum">    1488</span>                 :<span class="tlaUNC">           0 : static size_t ZSTDMT_flushProduced(ZSTDMT_CCtx* mtctx, ZSTD_outBuffer* output, unsigned blockToFlush, ZSTD_EndDirective end)</span></span>
<span id="L1489"><span class="lineNum">    1489</span>                 :             : {</span>
<span id="L1490"><span class="lineNum">    1490</span>                 :<span class="tlaUNC">           0 :     unsigned const wJobID = mtctx-&gt;doneJobID &amp; mtctx-&gt;jobIDMask;</span></span>
<span id="L1491"><span class="lineNum">    1491</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_flushProduced (blocking:%u , job %u &lt;= %u)&quot;,</span></span>
<span id="L1492"><span class="lineNum">    1492</span>                 :             :                 blockToFlush, mtctx-&gt;doneJobID, mtctx-&gt;nextJobID);</span>
<span id="L1493"><span class="lineNum">    1493</span>                 :             :     assert(output-&gt;size &gt;= output-&gt;pos);</span>
<span id="L1494"><span class="lineNum">    1494</span>                 :             : </span>
<span id="L1495"><span class="lineNum">    1495</span>                 :<span class="tlaUNC">           0 :     ZSTD_PTHREAD_MUTEX_LOCK(&amp;mtctx-&gt;jobs[wJobID].job_mutex);</span></span>
<span id="L1496"><span class="lineNum">    1496</span>                 :<span class="tlaUNC">           0 :     if (  blockToFlush</span></span>
<span id="L1497"><span class="lineNum">    1497</span>                 :<span class="tlaUNC">           0 :       &amp;&amp; (mtctx-&gt;doneJobID &lt; mtctx-&gt;nextJobID) ) {</span></span>
<span id="L1498"><span class="lineNum">    1498</span>                 :             :         assert(mtctx-&gt;jobs[wJobID].dstFlushed &lt;= mtctx-&gt;jobs[wJobID].cSize);</span>
<span id="L1499"><span class="lineNum">    1499</span>                 :<span class="tlaUNC">           0 :         while (mtctx-&gt;jobs[wJobID].dstFlushed == mtctx-&gt;jobs[wJobID].cSize) {  /* nothing to flush */</span></span>
<span id="L1500"><span class="lineNum">    1500</span>                 :<span class="tlaUNC">           0 :             if (mtctx-&gt;jobs[wJobID].consumed == mtctx-&gt;jobs[wJobID].src.size) {</span></span>
<span id="L1501"><span class="lineNum">    1501</span>                 :<span class="tlaUNC">           0 :                 DEBUGLOG(5, &quot;job %u is completely consumed (%u == %u) =&gt; don't wait for cond, there will be none&quot;,</span></span>
<span id="L1502"><span class="lineNum">    1502</span>                 :             :                             mtctx-&gt;doneJobID, (U32)mtctx-&gt;jobs[wJobID].consumed, (U32)mtctx-&gt;jobs[wJobID].src.size);</span>
<span id="L1503"><span class="lineNum">    1503</span>                 :<span class="tlaUNC">           0 :                 break;</span></span>
<span id="L1504"><span class="lineNum">    1504</span>                 :             :             }</span>
<span id="L1505"><span class="lineNum">    1505</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(5, &quot;waiting for something to flush from job %u (currently flushed: %u bytes)&quot;,</span></span>
<span id="L1506"><span class="lineNum">    1506</span>                 :             :                         mtctx-&gt;doneJobID, (U32)mtctx-&gt;jobs[wJobID].dstFlushed);</span>
<span id="L1507"><span class="lineNum">    1507</span>                 :<span class="tlaUNC">           0 :             ZSTD_pthread_cond_wait(&amp;mtctx-&gt;jobs[wJobID].job_cond, &amp;mtctx-&gt;jobs[wJobID].job_mutex);  /* block when nothing to flush but some to come */</span></span>
<span id="L1508"><span class="lineNum">    1508</span>                 :<span class="tlaUNC">           0 :     }   }</span></span>
<span id="L1509"><span class="lineNum">    1509</span>                 :             : </span>
<span id="L1510"><span class="lineNum">    1510</span>                 :             :     /* try to flush something */</span>
<span id="L1511"><span class="lineNum">    1511</span>                 :<span class="tlaUNC">           0 :     {   size_t cSize = mtctx-&gt;jobs[wJobID].cSize;                  /* shared */</span></span>
<span id="L1512"><span class="lineNum">    1512</span>                 :<span class="tlaUNC">           0 :         size_t const srcConsumed = mtctx-&gt;jobs[wJobID].consumed;   /* shared */</span></span>
<span id="L1513"><span class="lineNum">    1513</span>                 :<span class="tlaUNC">           0 :         size_t const srcSize = mtctx-&gt;jobs[wJobID].src.size;       /* read-only, could be done after mutex lock, but no-declaration-after-statement */</span></span>
<span id="L1514"><span class="lineNum">    1514</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_mutex_unlock(&amp;mtctx-&gt;jobs[wJobID].job_mutex);</span></span>
<span id="L1515"><span class="lineNum">    1515</span>                 :<span class="tlaUNC">           0 :         if (ZSTD_isError(cSize)) {</span></span>
<span id="L1516"><span class="lineNum">    1516</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(5, &quot;ZSTDMT_flushProduced: job %u : compression error detected : %s&quot;,</span></span>
<span id="L1517"><span class="lineNum">    1517</span>                 :             :                         mtctx-&gt;doneJobID, ZSTD_getErrorName(cSize));</span>
<span id="L1518"><span class="lineNum">    1518</span>                 :<span class="tlaUNC">           0 :             ZSTDMT_waitForAllJobsCompleted(mtctx);</span></span>
<span id="L1519"><span class="lineNum">    1519</span>                 :<span class="tlaUNC">           0 :             ZSTDMT_releaseAllJobResources(mtctx);</span></span>
<span id="L1520"><span class="lineNum">    1520</span>                 :<span class="tlaUNC">           0 :             return cSize;</span></span>
<span id="L1521"><span class="lineNum">    1521</span>                 :             :         }</span>
<span id="L1522"><span class="lineNum">    1522</span>                 :             :         /* add frame checksum if necessary (can only happen once) */</span>
<span id="L1523"><span class="lineNum">    1523</span>                 :             :         assert(srcConsumed &lt;= srcSize);</span>
<span id="L1524"><span class="lineNum">    1524</span>                 :<span class="tlaUNC">           0 :         if ( (srcConsumed == srcSize)   /* job completed -&gt; worker no longer active */</span></span>
<span id="L1525"><span class="lineNum">    1525</span>                 :<span class="tlaUNC">           0 :           &amp;&amp; mtctx-&gt;jobs[wJobID].frameChecksumNeeded ) {</span></span>
<span id="L1526"><span class="lineNum">    1526</span>                 :<span class="tlaUNC">           0 :             U32 const checksum = (U32)XXH64_digest(&amp;mtctx-&gt;serial.xxhState);</span></span>
<span id="L1527"><span class="lineNum">    1527</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(4, &quot;ZSTDMT_flushProduced: writing checksum : %08X \n&quot;, checksum);</span></span>
<span id="L1528"><span class="lineNum">    1528</span>                 :<span class="tlaUNC">           0 :             MEM_writeLE32((char*)mtctx-&gt;jobs[wJobID].dstBuff.start + mtctx-&gt;jobs[wJobID].cSize, checksum);</span></span>
<span id="L1529"><span class="lineNum">    1529</span>                 :<span class="tlaUNC">           0 :             cSize += 4;</span></span>
<span id="L1530"><span class="lineNum">    1530</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;jobs[wJobID].cSize += 4;  /* can write this shared value, as worker is no longer active */</span></span>
<span id="L1531"><span class="lineNum">    1531</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;jobs[wJobID].frameChecksumNeeded = 0;</span></span>
<span id="L1532"><span class="lineNum">    1532</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L1533"><span class="lineNum">    1533</span>                 :             : </span>
<span id="L1534"><span class="lineNum">    1534</span>                 :<span class="tlaUNC">           0 :         if (cSize &gt; 0) {   /* compression is ongoing or completed */</span></span>
<span id="L1535"><span class="lineNum">    1535</span>                 :<span class="tlaUNC">           0 :             size_t const toFlush = MIN(cSize - mtctx-&gt;jobs[wJobID].dstFlushed, output-&gt;size - output-&gt;pos);</span></span>
<span id="L1536"><span class="lineNum">    1536</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(5, &quot;ZSTDMT_flushProduced: Flushing %u bytes from job %u (completion:%u/%u, generated:%u)&quot;,</span></span>
<span id="L1537"><span class="lineNum">    1537</span>                 :             :                         (U32)toFlush, mtctx-&gt;doneJobID, (U32)srcConsumed, (U32)srcSize, (U32)cSize);</span>
<span id="L1538"><span class="lineNum">    1538</span>                 :             :             assert(mtctx-&gt;doneJobID &lt; mtctx-&gt;nextJobID);</span>
<span id="L1539"><span class="lineNum">    1539</span>                 :             :             assert(cSize &gt;= mtctx-&gt;jobs[wJobID].dstFlushed);</span>
<span id="L1540"><span class="lineNum">    1540</span>                 :             :             assert(mtctx-&gt;jobs[wJobID].dstBuff.start != NULL);</span>
<span id="L1541"><span class="lineNum">    1541</span>                 :<span class="tlaUNC">           0 :             if (toFlush &gt; 0) {</span></span>
<span id="L1542"><span class="lineNum">    1542</span>                 :<span class="tlaUNC">           0 :                 ZSTD_memcpy((char*)output-&gt;dst + output-&gt;pos,</span></span>
<span id="L1543"><span class="lineNum">    1543</span>                 :             :                     (const char*)mtctx-&gt;jobs[wJobID].dstBuff.start + mtctx-&gt;jobs[wJobID].dstFlushed,</span>
<span id="L1544"><span class="lineNum">    1544</span>                 :             :                     toFlush);</span>
<span id="L1545"><span class="lineNum">    1545</span>                 :<span class="tlaUNC">           0 :             }</span></span>
<span id="L1546"><span class="lineNum">    1546</span>                 :<span class="tlaUNC">           0 :             output-&gt;pos += toFlush;</span></span>
<span id="L1547"><span class="lineNum">    1547</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;jobs[wJobID].dstFlushed += toFlush;  /* can write : this value is only used by mtctx */</span></span>
<span id="L1548"><span class="lineNum">    1548</span>                 :             : </span>
<span id="L1549"><span class="lineNum">    1549</span>                 :<span class="tlaUNC">           0 :             if ( (srcConsumed == srcSize)    /* job is completed */</span></span>
<span id="L1550"><span class="lineNum">    1550</span>                 :<span class="tlaUNC">           0 :               &amp;&amp; (mtctx-&gt;jobs[wJobID].dstFlushed == cSize) ) {   /* output buffer fully flushed =&gt; free this job position */</span></span>
<span id="L1551"><span class="lineNum">    1551</span>                 :<span class="tlaUNC">           0 :                 DEBUGLOG(5, &quot;Job %u completed (%u bytes), moving to next one&quot;,</span></span>
<span id="L1552"><span class="lineNum">    1552</span>                 :             :                         mtctx-&gt;doneJobID, (U32)mtctx-&gt;jobs[wJobID].dstFlushed);</span>
<span id="L1553"><span class="lineNum">    1553</span>                 :<span class="tlaUNC">           0 :                 ZSTDMT_releaseBuffer(mtctx-&gt;bufPool, mtctx-&gt;jobs[wJobID].dstBuff);</span></span>
<span id="L1554"><span class="lineNum">    1554</span>                 :<span class="tlaUNC">           0 :                 DEBUGLOG(5, &quot;dstBuffer released&quot;);</span></span>
<span id="L1555"><span class="lineNum">    1555</span>                 :<span class="tlaUNC">           0 :                 mtctx-&gt;jobs[wJobID].dstBuff = g_nullBuffer;</span></span>
<span id="L1556"><span class="lineNum">    1556</span>                 :<span class="tlaUNC">           0 :                 mtctx-&gt;jobs[wJobID].cSize = 0;   /* ensure this job slot is considered &quot;not started&quot; in future check */</span></span>
<span id="L1557"><span class="lineNum">    1557</span>                 :<span class="tlaUNC">           0 :                 mtctx-&gt;consumed += srcSize;</span></span>
<span id="L1558"><span class="lineNum">    1558</span>                 :<span class="tlaUNC">           0 :                 mtctx-&gt;produced += cSize;</span></span>
<span id="L1559"><span class="lineNum">    1559</span>                 :<span class="tlaUNC">           0 :                 mtctx-&gt;doneJobID++;</span></span>
<span id="L1560"><span class="lineNum">    1560</span>                 :<span class="tlaUNC">           0 :         }   }</span></span>
<span id="L1561"><span class="lineNum">    1561</span>                 :             : </span>
<span id="L1562"><span class="lineNum">    1562</span>                 :             :         /* return value : how many bytes left in buffer ; fake it to 1 when unknown but &gt;0 */</span>
<span id="L1563"><span class="lineNum">    1563</span>                 :<span class="tlaUNC">           0 :         if (cSize &gt; mtctx-&gt;jobs[wJobID].dstFlushed) return (cSize - mtctx-&gt;jobs[wJobID].dstFlushed);</span></span>
<span id="L1564"><span class="lineNum">    1564</span>                 :<span class="tlaUNC">           0 :         if (srcSize &gt; srcConsumed) return 1;   /* current job not completely compressed */</span></span>
<span id="L1565"><span class="lineNum">    1565</span>                 :             :     }</span>
<span id="L1566"><span class="lineNum">    1566</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;doneJobID &lt; mtctx-&gt;nextJobID) return 1;   /* some more jobs ongoing */</span></span>
<span id="L1567"><span class="lineNum">    1567</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;jobReady) return 1;      /* one job is ready to push, just not yet in the list */</span></span>
<span id="L1568"><span class="lineNum">    1568</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;inBuff.filled &gt; 0) return 1;   /* input is not empty, and still needs to be converted into a job */</span></span>
<span id="L1569"><span class="lineNum">    1569</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;allJobsCompleted = mtctx-&gt;frameEnded;   /* all jobs are entirely flushed =&gt; if this one is last one, frame is completed */</span></span>
<span id="L1570"><span class="lineNum">    1570</span>                 :<span class="tlaUNC">           0 :     if (end == ZSTD_e_end) return !mtctx-&gt;frameEnded;  /* for ZSTD_e_end, question becomes : is frame completed ? instead of : are internal buffers fully flushed ? */</span></span>
<span id="L1571"><span class="lineNum">    1571</span>                 :<span class="tlaUNC">           0 :     return 0;   /* internal buffers fully flushed */</span></span>
<span id="L1572"><span class="lineNum">    1572</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1573"><span class="lineNum">    1573</span>                 :             : </span>
<span id="L1574"><span class="lineNum">    1574</span>                 :             : /**</span>
<span id="L1575"><span class="lineNum">    1575</span>                 :             :  * Returns the range of data used by the earliest job that is not yet complete.</span>
<span id="L1576"><span class="lineNum">    1576</span>                 :             :  * If the data of the first job is broken up into two segments, we cover both</span>
<span id="L1577"><span class="lineNum">    1577</span>                 :             :  * sections.</span>
<span id="L1578"><span class="lineNum">    1578</span>                 :             :  */</span>
<span id="L1579"><span class="lineNum">    1579</span>                 :<span class="tlaUNC">           0 : static Range ZSTDMT_getInputDataInUse(ZSTDMT_CCtx* mtctx)</span></span>
<span id="L1580"><span class="lineNum">    1580</span>                 :             : {</span>
<span id="L1581"><span class="lineNum">    1581</span>                 :<span class="tlaUNC">           0 :     unsigned const firstJobID = mtctx-&gt;doneJobID;</span></span>
<span id="L1582"><span class="lineNum">    1582</span>                 :<span class="tlaUNC">           0 :     unsigned const lastJobID = mtctx-&gt;nextJobID;</span></span>
<span id="L1583"><span class="lineNum">    1583</span>                 :             :     unsigned jobID;</span>
<span id="L1584"><span class="lineNum">    1584</span>                 :             : </span>
<span id="L1585"><span class="lineNum">    1585</span>                 :             :     /* no need to check during first round */</span>
<span id="L1586"><span class="lineNum">    1586</span>                 :<span class="tlaUNC">           0 :     size_t roundBuffCapacity = mtctx-&gt;roundBuff.capacity;</span></span>
<span id="L1587"><span class="lineNum">    1587</span>                 :<span class="tlaUNC">           0 :     size_t nbJobs1stRoundMin = roundBuffCapacity / mtctx-&gt;targetSectionSize;</span></span>
<span id="L1588"><span class="lineNum">    1588</span>                 :<span class="tlaUNC">           0 :     if (lastJobID &lt; nbJobs1stRoundMin) return kNullRange;</span></span>
<span id="L1589"><span class="lineNum">    1589</span>                 :             : </span>
<span id="L1590"><span class="lineNum">    1590</span>                 :<span class="tlaUNC">           0 :     for (jobID = firstJobID; jobID &lt; lastJobID; ++jobID) {</span></span>
<span id="L1591"><span class="lineNum">    1591</span>                 :<span class="tlaUNC">           0 :         unsigned const wJobID = jobID &amp; mtctx-&gt;jobIDMask;</span></span>
<span id="L1592"><span class="lineNum">    1592</span>                 :             :         size_t consumed;</span>
<span id="L1593"><span class="lineNum">    1593</span>                 :             : </span>
<span id="L1594"><span class="lineNum">    1594</span>                 :<span class="tlaUNC">           0 :         ZSTD_PTHREAD_MUTEX_LOCK(&amp;mtctx-&gt;jobs[wJobID].job_mutex);</span></span>
<span id="L1595"><span class="lineNum">    1595</span>                 :<span class="tlaUNC">           0 :         consumed = mtctx-&gt;jobs[wJobID].consumed;</span></span>
<span id="L1596"><span class="lineNum">    1596</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_mutex_unlock(&amp;mtctx-&gt;jobs[wJobID].job_mutex);</span></span>
<span id="L1597"><span class="lineNum">    1597</span>                 :             : </span>
<span id="L1598"><span class="lineNum">    1598</span>                 :<span class="tlaUNC">           0 :         if (consumed &lt; mtctx-&gt;jobs[wJobID].src.size) {</span></span>
<span id="L1599"><span class="lineNum">    1599</span>                 :<span class="tlaUNC">           0 :             Range range = mtctx-&gt;jobs[wJobID].prefix;</span></span>
<span id="L1600"><span class="lineNum">    1600</span>                 :<span class="tlaUNC">           0 :             if (range.size == 0) {</span></span>
<span id="L1601"><span class="lineNum">    1601</span>                 :             :                 /* Empty prefix */</span>
<span id="L1602"><span class="lineNum">    1602</span>                 :<span class="tlaUNC">           0 :                 range = mtctx-&gt;jobs[wJobID].src;</span></span>
<span id="L1603"><span class="lineNum">    1603</span>                 :<span class="tlaUNC">           0 :             }</span></span>
<span id="L1604"><span class="lineNum">    1604</span>                 :             :             /* Job source in multiple segments not supported yet */</span>
<span id="L1605"><span class="lineNum">    1605</span>                 :             :             assert(range.start &lt;= mtctx-&gt;jobs[wJobID].src.start);</span>
<span id="L1606"><span class="lineNum">    1606</span>                 :<span class="tlaUNC">           0 :             return range;</span></span>
<span id="L1607"><span class="lineNum">    1607</span>                 :             :         }</span>
<span id="L1608"><span class="lineNum">    1608</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1609"><span class="lineNum">    1609</span>                 :<span class="tlaUNC">           0 :     return kNullRange;</span></span>
<span id="L1610"><span class="lineNum">    1610</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1611"><span class="lineNum">    1611</span>                 :             : </span>
<span id="L1612"><span class="lineNum">    1612</span>                 :             : /**</span>
<span id="L1613"><span class="lineNum">    1613</span>                 :             :  * Returns non-zero iff buffer and range overlap.</span>
<span id="L1614"><span class="lineNum">    1614</span>                 :             :  */</span>
<span id="L1615"><span class="lineNum">    1615</span>                 :<span class="tlaUNC">           0 : static int ZSTDMT_isOverlapped(Buffer buffer, Range range)</span></span>
<span id="L1616"><span class="lineNum">    1616</span>                 :             : {</span>
<span id="L1617"><span class="lineNum">    1617</span>                 :<span class="tlaUNC">           0 :     BYTE const* const bufferStart = (BYTE const*)buffer.start;</span></span>
<span id="L1618"><span class="lineNum">    1618</span>                 :<span class="tlaUNC">           0 :     BYTE const* const rangeStart = (BYTE const*)range.start;</span></span>
<span id="L1619"><span class="lineNum">    1619</span>                 :             : </span>
<span id="L1620"><span class="lineNum">    1620</span>                 :<span class="tlaUNC">           0 :     if (rangeStart == NULL || bufferStart == NULL)</span></span>
<span id="L1621"><span class="lineNum">    1621</span>                 :<span class="tlaUNC">           0 :         return 0;</span></span>
<span id="L1622"><span class="lineNum">    1622</span>                 :             : </span>
<span id="L1623"><span class="lineNum">    1623</span>                 :             :     {</span>
<span id="L1624"><span class="lineNum">    1624</span>                 :<span class="tlaUNC">           0 :         BYTE const* const bufferEnd = bufferStart + buffer.capacity;</span></span>
<span id="L1625"><span class="lineNum">    1625</span>                 :<span class="tlaUNC">           0 :         BYTE const* const rangeEnd = rangeStart + range.size;</span></span>
<span id="L1626"><span class="lineNum">    1626</span>                 :             : </span>
<span id="L1627"><span class="lineNum">    1627</span>                 :             :         /* Empty ranges cannot overlap */</span>
<span id="L1628"><span class="lineNum">    1628</span>                 :<span class="tlaUNC">           0 :         if (bufferStart == bufferEnd || rangeStart == rangeEnd)</span></span>
<span id="L1629"><span class="lineNum">    1629</span>                 :<span class="tlaUNC">           0 :             return 0;</span></span>
<span id="L1630"><span class="lineNum">    1630</span>                 :             : </span>
<span id="L1631"><span class="lineNum">    1631</span>                 :<span class="tlaUNC">           0 :         return bufferStart &lt; rangeEnd &amp;&amp; rangeStart &lt; bufferEnd;</span></span>
<span id="L1632"><span class="lineNum">    1632</span>                 :             :     }</span>
<span id="L1633"><span class="lineNum">    1633</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1634"><span class="lineNum">    1634</span>                 :             : </span>
<span id="L1635"><span class="lineNum">    1635</span>                 :<span class="tlaUNC">           0 : static int ZSTDMT_doesOverlapWindow(Buffer buffer, ZSTD_window_t window)</span></span>
<span id="L1636"><span class="lineNum">    1636</span>                 :             : {</span>
<span id="L1637"><span class="lineNum">    1637</span>                 :             :     Range extDict;</span>
<span id="L1638"><span class="lineNum">    1638</span>                 :             :     Range prefix;</span>
<span id="L1639"><span class="lineNum">    1639</span>                 :             : </span>
<span id="L1640"><span class="lineNum">    1640</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_doesOverlapWindow&quot;);</span></span>
<span id="L1641"><span class="lineNum">    1641</span>                 :<span class="tlaUNC">           0 :     extDict.start = window.dictBase + window.lowLimit;</span></span>
<span id="L1642"><span class="lineNum">    1642</span>                 :<span class="tlaUNC">           0 :     extDict.size = window.dictLimit - window.lowLimit;</span></span>
<span id="L1643"><span class="lineNum">    1643</span>                 :             : </span>
<span id="L1644"><span class="lineNum">    1644</span>                 :<span class="tlaUNC">           0 :     prefix.start = window.base + window.dictLimit;</span></span>
<span id="L1645"><span class="lineNum">    1645</span>                 :<span class="tlaUNC">           0 :     prefix.size = window.nextSrc - (window.base + window.dictLimit);</span></span>
<span id="L1646"><span class="lineNum">    1646</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;extDict [0x%zx, 0x%zx)&quot;,</span></span>
<span id="L1647"><span class="lineNum">    1647</span>                 :             :                 (size_t)extDict.start,</span>
<span id="L1648"><span class="lineNum">    1648</span>                 :             :                 (size_t)extDict.start + extDict.size);</span>
<span id="L1649"><span class="lineNum">    1649</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;prefix  [0x%zx, 0x%zx)&quot;,</span></span>
<span id="L1650"><span class="lineNum">    1650</span>                 :             :                 (size_t)prefix.start,</span>
<span id="L1651"><span class="lineNum">    1651</span>                 :             :                 (size_t)prefix.start + prefix.size);</span>
<span id="L1652"><span class="lineNum">    1652</span>                 :             : </span>
<span id="L1653"><span class="lineNum">    1653</span>                 :<span class="tlaUNC">           0 :     return ZSTDMT_isOverlapped(buffer, extDict)</span></span>
<span id="L1654"><span class="lineNum">    1654</span>                 :<span class="tlaUNC">           0 :         || ZSTDMT_isOverlapped(buffer, prefix);</span></span>
<span id="L1655"><span class="lineNum">    1655</span>                 :             : }</span>
<span id="L1656"><span class="lineNum">    1656</span>                 :             : </span>
<span id="L1657"><span class="lineNum">    1657</span>                 :<span class="tlaUNC">           0 : static void ZSTDMT_waitForLdmComplete(ZSTDMT_CCtx* mtctx, Buffer buffer)</span></span>
<span id="L1658"><span class="lineNum">    1658</span>                 :             : {</span>
<span id="L1659"><span class="lineNum">    1659</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;params.ldmParams.enableLdm == ZSTD_ps_enable) {</span></span>
<span id="L1660"><span class="lineNum">    1660</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_mutex_t* mutex = &amp;mtctx-&gt;serial.ldmWindowMutex;</span></span>
<span id="L1661"><span class="lineNum">    1661</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;ZSTDMT_waitForLdmComplete&quot;);</span></span>
<span id="L1662"><span class="lineNum">    1662</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;source  [0x%zx, 0x%zx)&quot;,</span></span>
<span id="L1663"><span class="lineNum">    1663</span>                 :             :                     (size_t)buffer.start,</span>
<span id="L1664"><span class="lineNum">    1664</span>                 :             :                     (size_t)buffer.start + buffer.capacity);</span>
<span id="L1665"><span class="lineNum">    1665</span>                 :<span class="tlaUNC">           0 :         ZSTD_PTHREAD_MUTEX_LOCK(mutex);</span></span>
<span id="L1666"><span class="lineNum">    1666</span>                 :<span class="tlaUNC">           0 :         while (ZSTDMT_doesOverlapWindow(buffer, mtctx-&gt;serial.ldmWindow)) {</span></span>
<span id="L1667"><span class="lineNum">    1667</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(5, &quot;Waiting for LDM to finish...&quot;);</span></span>
<span id="L1668"><span class="lineNum">    1668</span>                 :<span class="tlaUNC">           0 :             ZSTD_pthread_cond_wait(&amp;mtctx-&gt;serial.ldmWindowCond, mutex);</span></span>
<span id="L1669"><span class="lineNum">    1669</span>                 :             :         }</span>
<span id="L1670"><span class="lineNum">    1670</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(6, &quot;Done waiting for LDM to finish&quot;);</span></span>
<span id="L1671"><span class="lineNum">    1671</span>                 :<span class="tlaUNC">           0 :         ZSTD_pthread_mutex_unlock(mutex);</span></span>
<span id="L1672"><span class="lineNum">    1672</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1673"><span class="lineNum">    1673</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1674"><span class="lineNum">    1674</span>                 :             : </span>
<span id="L1675"><span class="lineNum">    1675</span>                 :             : /**</span>
<span id="L1676"><span class="lineNum">    1676</span>                 :             :  * Attempts to set the inBuff to the next section to fill.</span>
<span id="L1677"><span class="lineNum">    1677</span>                 :             :  * If any part of the new section is still in use we give up.</span>
<span id="L1678"><span class="lineNum">    1678</span>                 :             :  * Returns non-zero if the buffer is filled.</span>
<span id="L1679"><span class="lineNum">    1679</span>                 :             :  */</span>
<span id="L1680"><span class="lineNum">    1680</span>                 :<span class="tlaUNC">           0 : static int ZSTDMT_tryGetInputRange(ZSTDMT_CCtx* mtctx)</span></span>
<span id="L1681"><span class="lineNum">    1681</span>                 :             : {</span>
<span id="L1682"><span class="lineNum">    1682</span>                 :<span class="tlaUNC">           0 :     Range const inUse = ZSTDMT_getInputDataInUse(mtctx);</span></span>
<span id="L1683"><span class="lineNum">    1683</span>                 :<span class="tlaUNC">           0 :     size_t const spaceLeft = mtctx-&gt;roundBuff.capacity - mtctx-&gt;roundBuff.pos;</span></span>
<span id="L1684"><span class="lineNum">    1684</span>                 :<span class="tlaUNC">           0 :     size_t const spaceNeeded = mtctx-&gt;targetSectionSize;</span></span>
<span id="L1685"><span class="lineNum">    1685</span>                 :             :     Buffer buffer;</span>
<span id="L1686"><span class="lineNum">    1686</span>                 :             : </span>
<span id="L1687"><span class="lineNum">    1687</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_tryGetInputRange&quot;);</span></span>
<span id="L1688"><span class="lineNum">    1688</span>                 :             :     assert(mtctx-&gt;inBuff.buffer.start == NULL);</span>
<span id="L1689"><span class="lineNum">    1689</span>                 :             :     assert(mtctx-&gt;roundBuff.capacity &gt;= spaceNeeded);</span>
<span id="L1690"><span class="lineNum">    1690</span>                 :             : </span>
<span id="L1691"><span class="lineNum">    1691</span>                 :<span class="tlaUNC">           0 :     if (spaceLeft &lt; spaceNeeded) {</span></span>
<span id="L1692"><span class="lineNum">    1692</span>                 :             :         /* ZSTD_invalidateRepCodes() doesn't work for extDict variants.</span>
<span id="L1693"><span class="lineNum">    1693</span>                 :             :          * Simply copy the prefix to the beginning in that case.</span>
<span id="L1694"><span class="lineNum">    1694</span>                 :             :          */</span>
<span id="L1695"><span class="lineNum">    1695</span>                 :<span class="tlaUNC">           0 :         BYTE* const start = (BYTE*)mtctx-&gt;roundBuff.buffer;</span></span>
<span id="L1696"><span class="lineNum">    1696</span>                 :<span class="tlaUNC">           0 :         size_t const prefixSize = mtctx-&gt;inBuff.prefix.size;</span></span>
<span id="L1697"><span class="lineNum">    1697</span>                 :             : </span>
<span id="L1698"><span class="lineNum">    1698</span>                 :<span class="tlaUNC">           0 :         buffer.start = start;</span></span>
<span id="L1699"><span class="lineNum">    1699</span>                 :<span class="tlaUNC">           0 :         buffer.capacity = prefixSize;</span></span>
<span id="L1700"><span class="lineNum">    1700</span>                 :<span class="tlaUNC">           0 :         if (ZSTDMT_isOverlapped(buffer, inUse)) {</span></span>
<span id="L1701"><span class="lineNum">    1701</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(5, &quot;Waiting for buffer...&quot;);</span></span>
<span id="L1702"><span class="lineNum">    1702</span>                 :<span class="tlaUNC">           0 :             return 0;</span></span>
<span id="L1703"><span class="lineNum">    1703</span>                 :             :         }</span>
<span id="L1704"><span class="lineNum">    1704</span>                 :<span class="tlaUNC">           0 :         ZSTDMT_waitForLdmComplete(mtctx, buffer);</span></span>
<span id="L1705"><span class="lineNum">    1705</span>                 :<span class="tlaUNC">           0 :         ZSTD_memmove(start, mtctx-&gt;inBuff.prefix.start, prefixSize);</span></span>
<span id="L1706"><span class="lineNum">    1706</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;inBuff.prefix.start = start;</span></span>
<span id="L1707"><span class="lineNum">    1707</span>                 :<span class="tlaUNC">           0 :         mtctx-&gt;roundBuff.pos = prefixSize;</span></span>
<span id="L1708"><span class="lineNum">    1708</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1709"><span class="lineNum">    1709</span>                 :<span class="tlaUNC">           0 :     buffer.start = mtctx-&gt;roundBuff.buffer + mtctx-&gt;roundBuff.pos;</span></span>
<span id="L1710"><span class="lineNum">    1710</span>                 :<span class="tlaUNC">           0 :     buffer.capacity = spaceNeeded;</span></span>
<span id="L1711"><span class="lineNum">    1711</span>                 :             : </span>
<span id="L1712"><span class="lineNum">    1712</span>                 :<span class="tlaUNC">           0 :     if (ZSTDMT_isOverlapped(buffer, inUse)) {</span></span>
<span id="L1713"><span class="lineNum">    1713</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;Waiting for buffer...&quot;);</span></span>
<span id="L1714"><span class="lineNum">    1714</span>                 :<span class="tlaUNC">           0 :         return 0;</span></span>
<span id="L1715"><span class="lineNum">    1715</span>                 :             :     }</span>
<span id="L1716"><span class="lineNum">    1716</span>                 :             :     assert(!ZSTDMT_isOverlapped(buffer, mtctx-&gt;inBuff.prefix));</span>
<span id="L1717"><span class="lineNum">    1717</span>                 :             : </span>
<span id="L1718"><span class="lineNum">    1718</span>                 :<span class="tlaUNC">           0 :     ZSTDMT_waitForLdmComplete(mtctx, buffer);</span></span>
<span id="L1719"><span class="lineNum">    1719</span>                 :             : </span>
<span id="L1720"><span class="lineNum">    1720</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;Using prefix range [%zx, %zx)&quot;,</span></span>
<span id="L1721"><span class="lineNum">    1721</span>                 :             :                 (size_t)mtctx-&gt;inBuff.prefix.start,</span>
<span id="L1722"><span class="lineNum">    1722</span>                 :             :                 (size_t)mtctx-&gt;inBuff.prefix.start + mtctx-&gt;inBuff.prefix.size);</span>
<span id="L1723"><span class="lineNum">    1723</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;Using source range [%zx, %zx)&quot;,</span></span>
<span id="L1724"><span class="lineNum">    1724</span>                 :             :                 (size_t)buffer.start,</span>
<span id="L1725"><span class="lineNum">    1725</span>                 :             :                 (size_t)buffer.start + buffer.capacity);</span>
<span id="L1726"><span class="lineNum">    1726</span>                 :             : </span>
<span id="L1727"><span class="lineNum">    1727</span>                 :             : </span>
<span id="L1728"><span class="lineNum">    1728</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;inBuff.buffer = buffer;</span></span>
<span id="L1729"><span class="lineNum">    1729</span>                 :<span class="tlaUNC">           0 :     mtctx-&gt;inBuff.filled = 0;</span></span>
<span id="L1730"><span class="lineNum">    1730</span>                 :             :     assert(mtctx-&gt;roundBuff.pos + buffer.capacity &lt;= mtctx-&gt;roundBuff.capacity);</span>
<span id="L1731"><span class="lineNum">    1731</span>                 :<span class="tlaUNC">           0 :     return 1;</span></span>
<span id="L1732"><span class="lineNum">    1732</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1733"><span class="lineNum">    1733</span>                 :             : </span>
<span id="L1734"><span class="lineNum">    1734</span>                 :             : typedef struct {</span>
<span id="L1735"><span class="lineNum">    1735</span>                 :             :   size_t toLoad;  /* The number of bytes to load from the input. */</span>
<span id="L1736"><span class="lineNum">    1736</span>                 :             :   int flush;      /* Boolean declaring if we must flush because we found a synchronization point. */</span>
<span id="L1737"><span class="lineNum">    1737</span>                 :             : } SyncPoint;</span>
<span id="L1738"><span class="lineNum">    1738</span>                 :             : </span>
<span id="L1739"><span class="lineNum">    1739</span>                 :             : /**</span>
<span id="L1740"><span class="lineNum">    1740</span>                 :             :  * Searches through the input for a synchronization point. If one is found, we</span>
<span id="L1741"><span class="lineNum">    1741</span>                 :             :  * will instruct the caller to flush, and return the number of bytes to load.</span>
<span id="L1742"><span class="lineNum">    1742</span>                 :             :  * Otherwise, we will load as many bytes as possible and instruct the caller</span>
<span id="L1743"><span class="lineNum">    1743</span>                 :             :  * to continue as normal.</span>
<span id="L1744"><span class="lineNum">    1744</span>                 :             :  */</span>
<span id="L1745"><span class="lineNum">    1745</span>                 :             : static SyncPoint</span>
<span id="L1746"><span class="lineNum">    1746</span>                 :<span class="tlaUNC">           0 : findSynchronizationPoint(ZSTDMT_CCtx const* mtctx, ZSTD_inBuffer const input)</span></span>
<span id="L1747"><span class="lineNum">    1747</span>                 :             : {</span>
<span id="L1748"><span class="lineNum">    1748</span>                 :<span class="tlaUNC">           0 :     BYTE const* const istart = (BYTE const*)input.src + input.pos;</span></span>
<span id="L1749"><span class="lineNum">    1749</span>                 :<span class="tlaUNC">           0 :     U64 const primePower = mtctx-&gt;rsync.primePower;</span></span>
<span id="L1750"><span class="lineNum">    1750</span>                 :<span class="tlaUNC">           0 :     U64 const hitMask = mtctx-&gt;rsync.hitMask;</span></span>
<span id="L1751"><span class="lineNum">    1751</span>                 :             : </span>
<span id="L1752"><span class="lineNum">    1752</span>                 :             :     SyncPoint syncPoint;</span>
<span id="L1753"><span class="lineNum">    1753</span>                 :             :     U64 hash;</span>
<span id="L1754"><span class="lineNum">    1754</span>                 :             :     BYTE const* prev;</span>
<span id="L1755"><span class="lineNum">    1755</span>                 :             :     size_t pos;</span>
<span id="L1756"><span class="lineNum">    1756</span>                 :             : </span>
<span id="L1757"><span class="lineNum">    1757</span>                 :<span class="tlaUNC">           0 :     syncPoint.toLoad = MIN(input.size - input.pos, mtctx-&gt;targetSectionSize - mtctx-&gt;inBuff.filled);</span></span>
<span id="L1758"><span class="lineNum">    1758</span>                 :<span class="tlaUNC">           0 :     syncPoint.flush = 0;</span></span>
<span id="L1759"><span class="lineNum">    1759</span>                 :<span class="tlaUNC">           0 :     if (!mtctx-&gt;params.rsyncable)</span></span>
<span id="L1760"><span class="lineNum">    1760</span>                 :             :         /* Rsync is disabled. */</span>
<span id="L1761"><span class="lineNum">    1761</span>                 :<span class="tlaUNC">           0 :         return syncPoint;</span></span>
<span id="L1762"><span class="lineNum">    1762</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;inBuff.filled + input.size - input.pos &lt; RSYNC_MIN_BLOCK_SIZE)</span></span>
<span id="L1763"><span class="lineNum">    1763</span>                 :             :         /* We don't emit synchronization points if it would produce too small blocks.</span>
<span id="L1764"><span class="lineNum">    1764</span>                 :             :          * We don't have enough input to find a synchronization point, so don't look.</span>
<span id="L1765"><span class="lineNum">    1765</span>                 :             :          */</span>
<span id="L1766"><span class="lineNum">    1766</span>                 :<span class="tlaUNC">           0 :         return syncPoint;</span></span>
<span id="L1767"><span class="lineNum">    1767</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;inBuff.filled + syncPoint.toLoad &lt; RSYNC_LENGTH)</span></span>
<span id="L1768"><span class="lineNum">    1768</span>                 :             :         /* Not enough to compute the hash.</span>
<span id="L1769"><span class="lineNum">    1769</span>                 :             :          * We will miss any synchronization points in this RSYNC_LENGTH byte</span>
<span id="L1770"><span class="lineNum">    1770</span>                 :             :          * window. However, since it depends only in the internal buffers, if the</span>
<span id="L1771"><span class="lineNum">    1771</span>                 :             :          * state is already synchronized, we will remain synchronized.</span>
<span id="L1772"><span class="lineNum">    1772</span>                 :             :          * Additionally, the probability that we miss a synchronization point is</span>
<span id="L1773"><span class="lineNum">    1773</span>                 :             :          * low: RSYNC_LENGTH / targetSectionSize.</span>
<span id="L1774"><span class="lineNum">    1774</span>                 :             :          */</span>
<span id="L1775"><span class="lineNum">    1775</span>                 :<span class="tlaUNC">           0 :         return syncPoint;</span></span>
<span id="L1776"><span class="lineNum">    1776</span>                 :             :     /* Initialize the loop variables. */</span>
<span id="L1777"><span class="lineNum">    1777</span>                 :<span class="tlaUNC">           0 :     if (mtctx-&gt;inBuff.filled &lt; RSYNC_MIN_BLOCK_SIZE) {</span></span>
<span id="L1778"><span class="lineNum">    1778</span>                 :             :         /* We don't need to scan the first RSYNC_MIN_BLOCK_SIZE positions</span>
<span id="L1779"><span class="lineNum">    1779</span>                 :             :          * because they can't possibly be a sync point. So we can start</span>
<span id="L1780"><span class="lineNum">    1780</span>                 :             :          * part way through the input buffer.</span>
<span id="L1781"><span class="lineNum">    1781</span>                 :             :          */</span>
<span id="L1782"><span class="lineNum">    1782</span>                 :<span class="tlaUNC">           0 :         pos = RSYNC_MIN_BLOCK_SIZE - mtctx-&gt;inBuff.filled;</span></span>
<span id="L1783"><span class="lineNum">    1783</span>                 :<span class="tlaUNC">           0 :         if (pos &gt;= RSYNC_LENGTH) {</span></span>
<span id="L1784"><span class="lineNum">    1784</span>                 :<span class="tlaUNC">           0 :             prev = istart + pos - RSYNC_LENGTH;</span></span>
<span id="L1785"><span class="lineNum">    1785</span>                 :<span class="tlaUNC">           0 :             hash = ZSTD_rollingHash_compute(prev, RSYNC_LENGTH);</span></span>
<span id="L1786"><span class="lineNum">    1786</span>                 :<span class="tlaUNC">           0 :         } else {</span></span>
<span id="L1787"><span class="lineNum">    1787</span>                 :             :             assert(mtctx-&gt;inBuff.filled &gt;= RSYNC_LENGTH);</span>
<span id="L1788"><span class="lineNum">    1788</span>                 :<span class="tlaUNC">           0 :             prev = (BYTE const*)mtctx-&gt;inBuff.buffer.start + mtctx-&gt;inBuff.filled - RSYNC_LENGTH;</span></span>
<span id="L1789"><span class="lineNum">    1789</span>                 :<span class="tlaUNC">           0 :             hash = ZSTD_rollingHash_compute(prev + pos, (RSYNC_LENGTH - pos));</span></span>
<span id="L1790"><span class="lineNum">    1790</span>                 :<span class="tlaUNC">           0 :             hash = ZSTD_rollingHash_append(hash, istart, pos);</span></span>
<span id="L1791"><span class="lineNum">    1791</span>                 :             :         }</span>
<span id="L1792"><span class="lineNum">    1792</span>                 :<span class="tlaUNC">           0 :     } else {</span></span>
<span id="L1793"><span class="lineNum">    1793</span>                 :             :         /* We have enough bytes buffered to initialize the hash,</span>
<span id="L1794"><span class="lineNum">    1794</span>                 :             :          * and have processed enough bytes to find a sync point.</span>
<span id="L1795"><span class="lineNum">    1795</span>                 :             :          * Start scanning at the beginning of the input.</span>
<span id="L1796"><span class="lineNum">    1796</span>                 :             :          */</span>
<span id="L1797"><span class="lineNum">    1797</span>                 :             :         assert(mtctx-&gt;inBuff.filled &gt;= RSYNC_MIN_BLOCK_SIZE);</span>
<span id="L1798"><span class="lineNum">    1798</span>                 :             :         assert(RSYNC_MIN_BLOCK_SIZE &gt;= RSYNC_LENGTH);</span>
<span id="L1799"><span class="lineNum">    1799</span>                 :<span class="tlaUNC">           0 :         pos = 0;</span></span>
<span id="L1800"><span class="lineNum">    1800</span>                 :<span class="tlaUNC">           0 :         prev = (BYTE const*)mtctx-&gt;inBuff.buffer.start + mtctx-&gt;inBuff.filled - RSYNC_LENGTH;</span></span>
<span id="L1801"><span class="lineNum">    1801</span>                 :<span class="tlaUNC">           0 :         hash = ZSTD_rollingHash_compute(prev, RSYNC_LENGTH);</span></span>
<span id="L1802"><span class="lineNum">    1802</span>                 :<span class="tlaUNC">           0 :         if ((hash &amp; hitMask) == hitMask) {</span></span>
<span id="L1803"><span class="lineNum">    1803</span>                 :             :             /* We're already at a sync point so don't load any more until</span>
<span id="L1804"><span class="lineNum">    1804</span>                 :             :              * we're able to flush this sync point.</span>
<span id="L1805"><span class="lineNum">    1805</span>                 :             :              * This likely happened because the job table was full so we</span>
<span id="L1806"><span class="lineNum">    1806</span>                 :             :              * couldn't add our job.</span>
<span id="L1807"><span class="lineNum">    1807</span>                 :             :              */</span>
<span id="L1808"><span class="lineNum">    1808</span>                 :<span class="tlaUNC">           0 :             syncPoint.toLoad = 0;</span></span>
<span id="L1809"><span class="lineNum">    1809</span>                 :<span class="tlaUNC">           0 :             syncPoint.flush = 1;</span></span>
<span id="L1810"><span class="lineNum">    1810</span>                 :<span class="tlaUNC">           0 :             return syncPoint;</span></span>
<span id="L1811"><span class="lineNum">    1811</span>                 :             :         }</span>
<span id="L1812"><span class="lineNum">    1812</span>                 :             :     }</span>
<span id="L1813"><span class="lineNum">    1813</span>                 :             :     /* Starting with the hash of the previous RSYNC_LENGTH bytes, roll</span>
<span id="L1814"><span class="lineNum">    1814</span>                 :             :      * through the input. If we hit a synchronization point, then cut the</span>
<span id="L1815"><span class="lineNum">    1815</span>                 :             :      * job off, and tell the compressor to flush the job. Otherwise, load</span>
<span id="L1816"><span class="lineNum">    1816</span>                 :             :      * all the bytes and continue as normal.</span>
<span id="L1817"><span class="lineNum">    1817</span>                 :             :      * If we go too long without a synchronization point (targetSectionSize)</span>
<span id="L1818"><span class="lineNum">    1818</span>                 :             :      * then a block will be emitted anyways, but this is okay, since if we</span>
<span id="L1819"><span class="lineNum">    1819</span>                 :             :      * are already synchronized we will remain synchronized.</span>
<span id="L1820"><span class="lineNum">    1820</span>                 :             :      */</span>
<span id="L1821"><span class="lineNum">    1821</span>                 :             :     assert(pos &lt; RSYNC_LENGTH || ZSTD_rollingHash_compute(istart + pos - RSYNC_LENGTH, RSYNC_LENGTH) == hash);</span>
<span id="L1822"><span class="lineNum">    1822</span>                 :<span class="tlaUNC">           0 :     for (; pos &lt; syncPoint.toLoad; ++pos) {</span></span>
<span id="L1823"><span class="lineNum">    1823</span>                 :<span class="tlaUNC">           0 :         BYTE const toRemove = pos &lt; RSYNC_LENGTH ? prev[pos] : istart[pos - RSYNC_LENGTH];</span></span>
<span id="L1824"><span class="lineNum">    1824</span>                 :             :         /* This assert is very expensive, and Debian compiles with asserts enabled.</span>
<span id="L1825"><span class="lineNum">    1825</span>                 :             :          * So disable it for now. We can get similar coverage by checking it at the</span>
<span id="L1826"><span class="lineNum">    1826</span>                 :             :          * beginning &amp; end of the loop.</span>
<span id="L1827"><span class="lineNum">    1827</span>                 :             :          * assert(pos &lt; RSYNC_LENGTH || ZSTD_rollingHash_compute(istart + pos - RSYNC_LENGTH, RSYNC_LENGTH) == hash);</span>
<span id="L1828"><span class="lineNum">    1828</span>                 :             :          */</span>
<span id="L1829"><span class="lineNum">    1829</span>                 :<span class="tlaUNC">           0 :         hash = ZSTD_rollingHash_rotate(hash, toRemove, istart[pos], primePower);</span></span>
<span id="L1830"><span class="lineNum">    1830</span>                 :             :         assert(mtctx-&gt;inBuff.filled + pos &gt;= RSYNC_MIN_BLOCK_SIZE);</span>
<span id="L1831"><span class="lineNum">    1831</span>                 :<span class="tlaUNC">           0 :         if ((hash &amp; hitMask) == hitMask) {</span></span>
<span id="L1832"><span class="lineNum">    1832</span>                 :<span class="tlaUNC">           0 :             syncPoint.toLoad = pos + 1;</span></span>
<span id="L1833"><span class="lineNum">    1833</span>                 :<span class="tlaUNC">           0 :             syncPoint.flush = 1;</span></span>
<span id="L1834"><span class="lineNum">    1834</span>                 :<span class="tlaUNC">           0 :             ++pos; /* for assert */</span></span>
<span id="L1835"><span class="lineNum">    1835</span>                 :<span class="tlaUNC">           0 :             break;</span></span>
<span id="L1836"><span class="lineNum">    1836</span>                 :             :         }</span>
<span id="L1837"><span class="lineNum">    1837</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1838"><span class="lineNum">    1838</span>                 :             :     assert(pos &lt; RSYNC_LENGTH || ZSTD_rollingHash_compute(istart + pos - RSYNC_LENGTH, RSYNC_LENGTH) == hash);</span>
<span id="L1839"><span class="lineNum">    1839</span>                 :<span class="tlaUNC">           0 :     return syncPoint;</span></span>
<span id="L1840"><span class="lineNum">    1840</span>                 :<span class="tlaUNC">           0 : }</span></span>
<span id="L1841"><span class="lineNum">    1841</span>                 :             : </span>
<span id="L1842"><span class="lineNum">    1842</span>                 :<span class="tlaUNC">           0 : size_t ZSTDMT_nextInputSizeHint(const ZSTDMT_CCtx* mtctx)</span></span>
<span id="L1843"><span class="lineNum">    1843</span>                 :             : {</span>
<span id="L1844"><span class="lineNum">    1844</span>                 :<span class="tlaUNC">           0 :     size_t hintInSize = mtctx-&gt;targetSectionSize - mtctx-&gt;inBuff.filled;</span></span>
<span id="L1845"><span class="lineNum">    1845</span>                 :<span class="tlaUNC">           0 :     if (hintInSize==0) hintInSize = mtctx-&gt;targetSectionSize;</span></span>
<span id="L1846"><span class="lineNum">    1846</span>                 :<span class="tlaUNC">           0 :     return hintInSize;</span></span>
<span id="L1847"><span class="lineNum">    1847</span>                 :             : }</span>
<span id="L1848"><span class="lineNum">    1848</span>                 :             : </span>
<span id="L1849"><span class="lineNum">    1849</span>                 :             : /** ZSTDMT_compressStream_generic() :</span>
<span id="L1850"><span class="lineNum">    1850</span>                 :             :  *  internal use only - exposed to be invoked from zstd_compress.c</span>
<span id="L1851"><span class="lineNum">    1851</span>                 :             :  *  assumption : output and input are valid (pos &lt;= size)</span>
<span id="L1852"><span class="lineNum">    1852</span>                 :             :  * @return : minimum amount of data remaining to flush, 0 if none */</span>
<span id="L1853"><span class="lineNum">    1853</span>                 :<span class="tlaUNC">           0 : size_t ZSTDMT_compressStream_generic(ZSTDMT_CCtx* mtctx,</span></span>
<span id="L1854"><span class="lineNum">    1854</span>                 :             :                                      ZSTD_outBuffer* output,</span>
<span id="L1855"><span class="lineNum">    1855</span>                 :             :                                      ZSTD_inBuffer* input,</span>
<span id="L1856"><span class="lineNum">    1856</span>                 :             :                                      ZSTD_EndDirective endOp)</span>
<span id="L1857"><span class="lineNum">    1857</span>                 :             : {</span>
<span id="L1858"><span class="lineNum">    1858</span>                 :<span class="tlaUNC">           0 :     unsigned forwardInputProgress = 0;</span></span>
<span id="L1859"><span class="lineNum">    1859</span>                 :<span class="tlaUNC">           0 :     DEBUGLOG(5, &quot;ZSTDMT_compressStream_generic (endOp=%u, srcSize=%u)&quot;,</span></span>
<span id="L1860"><span class="lineNum">    1860</span>                 :             :                 (U32)endOp, (U32)(input-&gt;size - input-&gt;pos));</span>
<span id="L1861"><span class="lineNum">    1861</span>                 :             :     assert(output-&gt;pos &lt;= output-&gt;size);</span>
<span id="L1862"><span class="lineNum">    1862</span>                 :             :     assert(input-&gt;pos  &lt;= input-&gt;size);</span>
<span id="L1863"><span class="lineNum">    1863</span>                 :             : </span>
<span id="L1864"><span class="lineNum">    1864</span>                 :<span class="tlaUNC">           0 :     if ((mtctx-&gt;frameEnded) &amp;&amp; (endOp==ZSTD_e_continue)) {</span></span>
<span id="L1865"><span class="lineNum">    1865</span>                 :             :         /* current frame being ended. Only flush/end are allowed */</span>
<span id="L1866"><span class="lineNum">    1866</span>                 :<span class="tlaUNC">           0 :         return ERROR(stage_wrong);</span></span>
<span id="L1867"><span class="lineNum">    1867</span>                 :             :     }</span>
<span id="L1868"><span class="lineNum">    1868</span>                 :             : </span>
<span id="L1869"><span class="lineNum">    1869</span>                 :             :     /* fill input buffer */</span>
<span id="L1870"><span class="lineNum">    1870</span>                 :<span class="tlaUNC">           0 :     if ( (!mtctx-&gt;jobReady)</span></span>
<span id="L1871"><span class="lineNum">    1871</span>                 :<span class="tlaUNC">           0 :       &amp;&amp; (input-&gt;size &gt; input-&gt;pos) ) {   /* support NULL input */</span></span>
<span id="L1872"><span class="lineNum">    1872</span>                 :<span class="tlaUNC">           0 :         if (mtctx-&gt;inBuff.buffer.start == NULL) {</span></span>
<span id="L1873"><span class="lineNum">    1873</span>                 :             :             assert(mtctx-&gt;inBuff.filled == 0); /* Can't fill an empty buffer */</span>
<span id="L1874"><span class="lineNum">    1874</span>                 :<span class="tlaUNC">           0 :             if (!ZSTDMT_tryGetInputRange(mtctx)) {</span></span>
<span id="L1875"><span class="lineNum">    1875</span>                 :             :                 /* It is only possible for this operation to fail if there are</span>
<span id="L1876"><span class="lineNum">    1876</span>                 :             :                  * still compression jobs ongoing.</span>
<span id="L1877"><span class="lineNum">    1877</span>                 :             :                  */</span>
<span id="L1878"><span class="lineNum">    1878</span>                 :<span class="tlaUNC">           0 :                 DEBUGLOG(5, &quot;ZSTDMT_tryGetInputRange failed&quot;);</span></span>
<span id="L1879"><span class="lineNum">    1879</span>                 :             :                 assert(mtctx-&gt;doneJobID != mtctx-&gt;nextJobID);</span>
<span id="L1880"><span class="lineNum">    1880</span>                 :<span class="tlaUNC">           0 :             } else</span></span>
<span id="L1881"><span class="lineNum">    1881</span>                 :<span class="tlaUNC">           0 :                 DEBUGLOG(5, &quot;ZSTDMT_tryGetInputRange completed successfully : mtctx-&gt;inBuff.buffer.start = %p&quot;, mtctx-&gt;inBuff.buffer.start);</span></span>
<span id="L1882"><span class="lineNum">    1882</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L1883"><span class="lineNum">    1883</span>                 :<span class="tlaUNC">           0 :         if (mtctx-&gt;inBuff.buffer.start != NULL) {</span></span>
<span id="L1884"><span class="lineNum">    1884</span>                 :<span class="tlaUNC">           0 :             SyncPoint const syncPoint = findSynchronizationPoint(mtctx, *input);</span></span>
<span id="L1885"><span class="lineNum">    1885</span>                 :<span class="tlaUNC">           0 :             if (syncPoint.flush &amp;&amp; endOp == ZSTD_e_continue) {</span></span>
<span id="L1886"><span class="lineNum">    1886</span>                 :<span class="tlaUNC">           0 :                 endOp = ZSTD_e_flush;</span></span>
<span id="L1887"><span class="lineNum">    1887</span>                 :<span class="tlaUNC">           0 :             }</span></span>
<span id="L1888"><span class="lineNum">    1888</span>                 :             :             assert(mtctx-&gt;inBuff.buffer.capacity &gt;= mtctx-&gt;targetSectionSize);</span>
<span id="L1889"><span class="lineNum">    1889</span>                 :<span class="tlaUNC">           0 :             DEBUGLOG(5, &quot;ZSTDMT_compressStream_generic: adding %u bytes on top of %u to buffer of size %u&quot;,</span></span>
<span id="L1890"><span class="lineNum">    1890</span>                 :             :                         (U32)syncPoint.toLoad, (U32)mtctx-&gt;inBuff.filled, (U32)mtctx-&gt;targetSectionSize);</span>
<span id="L1891"><span class="lineNum">    1891</span>                 :<span class="tlaUNC">           0 :             ZSTD_memcpy((char*)mtctx-&gt;inBuff.buffer.start + mtctx-&gt;inBuff.filled, (const char*)input-&gt;src + input-&gt;pos, syncPoint.toLoad);</span></span>
<span id="L1892"><span class="lineNum">    1892</span>                 :<span class="tlaUNC">           0 :             input-&gt;pos += syncPoint.toLoad;</span></span>
<span id="L1893"><span class="lineNum">    1893</span>                 :<span class="tlaUNC">           0 :             mtctx-&gt;inBuff.filled += syncPoint.toLoad;</span></span>
<span id="L1894"><span class="lineNum">    1894</span>                 :<span class="tlaUNC">           0 :             forwardInputProgress = syncPoint.toLoad&gt;0;</span></span>
<span id="L1895"><span class="lineNum">    1895</span>                 :<span class="tlaUNC">           0 :         }</span></span>
<span id="L1896"><span class="lineNum">    1896</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1897"><span class="lineNum">    1897</span>                 :<span class="tlaUNC">           0 :     if ((input-&gt;pos &lt; input-&gt;size) &amp;&amp; (endOp == ZSTD_e_end)) {</span></span>
<span id="L1898"><span class="lineNum">    1898</span>                 :             :         /* Can't end yet because the input is not fully consumed.</span>
<span id="L1899"><span class="lineNum">    1899</span>                 :             :             * We are in one of these cases:</span>
<span id="L1900"><span class="lineNum">    1900</span>                 :             :             * - mtctx-&gt;inBuff is NULL &amp; empty: we couldn't get an input buffer so don't create a new job.</span>
<span id="L1901"><span class="lineNum">    1901</span>                 :             :             * - We filled the input buffer: flush this job but don't end the frame.</span>
<span id="L1902"><span class="lineNum">    1902</span>                 :             :             * - We hit a synchronization point: flush this job but don't end the frame.</span>
<span id="L1903"><span class="lineNum">    1903</span>                 :             :             */</span>
<span id="L1904"><span class="lineNum">    1904</span>                 :             :         assert(mtctx-&gt;inBuff.filled == 0 || mtctx-&gt;inBuff.filled == mtctx-&gt;targetSectionSize || mtctx-&gt;params.rsyncable);</span>
<span id="L1905"><span class="lineNum">    1905</span>                 :<span class="tlaUNC">           0 :         endOp = ZSTD_e_flush;</span></span>
<span id="L1906"><span class="lineNum">    1906</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1907"><span class="lineNum">    1907</span>                 :             : </span>
<span id="L1908"><span class="lineNum">    1908</span>                 :<span class="tlaUNC">           0 :     if ( (mtctx-&gt;jobReady)</span></span>
<span id="L1909"><span class="lineNum">    1909</span>                 :<span class="tlaUNC">           0 :       || (mtctx-&gt;inBuff.filled &gt;= mtctx-&gt;targetSectionSize)  /* filled enough : let's compress */</span></span>
<span id="L1910"><span class="lineNum">    1910</span>                 :<span class="tlaUNC">           0 :       || ((endOp != ZSTD_e_continue) &amp;&amp; (mtctx-&gt;inBuff.filled &gt; 0))  /* something to flush : let's go */</span></span>
<span id="L1911"><span class="lineNum">    1911</span>                 :<span class="tlaUNC">           0 :       || ((endOp == ZSTD_e_end) &amp;&amp; (!mtctx-&gt;frameEnded)) ) {   /* must finish the frame with a zero-size block */</span></span>
<span id="L1912"><span class="lineNum">    1912</span>                 :<span class="tlaUNC">           0 :         size_t const jobSize = mtctx-&gt;inBuff.filled;</span></span>
<span id="L1913"><span class="lineNum">    1913</span>                 :             :         assert(mtctx-&gt;inBuff.filled &lt;= mtctx-&gt;targetSectionSize);</span>
<span id="L1914"><span class="lineNum">    1914</span>                 :<span class="tlaUNC">           0 :         FORWARD_IF_ERROR( ZSTDMT_createCompressionJob(mtctx, jobSize, endOp) , &quot;&quot;);</span></span>
<span id="L1915"><span class="lineNum">    1915</span>                 :<span class="tlaUNC">           0 :     }</span></span>
<span id="L1916"><span class="lineNum">    1916</span>                 :             : </span>
<span id="L1917"><span class="lineNum">    1917</span>                 :             :     /* check for potential compressed data ready to be flushed */</span>
<span id="L1918"><span class="lineNum">    1918</span>                 :<span class="tlaUNC">           0 :     {   size_t const remainingToFlush = ZSTDMT_flushProduced(mtctx, output, !forwardInputProgress, endOp); /* block if there was no forward input progress */</span></span>
<span id="L1919"><span class="lineNum">    1919</span>                 :<span class="tlaUNC">           0 :         if (input-&gt;pos &lt; input-&gt;size) return MAX(remainingToFlush, 1);  /* input not consumed : do not end flush yet */</span></span>
<span id="L1920"><span class="lineNum">    1920</span>                 :<span class="tlaUNC">           0 :         DEBUGLOG(5, &quot;end of ZSTDMT_compressStream_generic: remainingToFlush = %u&quot;, (U32)remainingToFlush);</span></span>
<span id="L1921"><span class="lineNum">    1921</span>                 :<span class="tlaUNC">           0 :         return remainingToFlush;</span></span>
<span id="L1922"><span class="lineNum">    1922</span>                 :             :     }</span>
<span id="L1923"><span class="lineNum">    1923</span>                 :<span class="tlaUNC">           0 : }</span></span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../../../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version 2.0-1</a></td></tr>
          </table>
          <br>

</body>
</html>
